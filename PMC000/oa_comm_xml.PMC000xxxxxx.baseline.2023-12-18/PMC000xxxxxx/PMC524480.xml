<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="product-review"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">15471541</article-id><article-id pub-id-type="pmc">PMC524480</article-id><article-id pub-id-type="publisher-id">1471-2105-5-146</article-id><article-id pub-id-type="doi">10.1186/1471-2105-5-146</article-id><article-categories><subj-group subj-group-type="heading"><subject>Software</subject></subj-group></article-categories><title-group><article-title>Tools for loading MEDLINE into a local relational database</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Oliver</surname><given-names>Diane E</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>oliver@SMI.Stanford.EDU</email></contrib><contrib id="A2" contrib-type="author"><name><surname>Bhalotia</surname><given-names>Gaurav</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>bhalotia@sims.berkeley.edu</email></contrib><contrib id="A3" corresp="yes" contrib-type="author"><name><surname>Schwartz</surname><given-names>Ariel S</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>sariel@cs.berkeley.edu</email></contrib><contrib id="A4" contrib-type="author"><name><surname>Altman</surname><given-names>Russ B</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>russ.altman@stanford.edu</email></contrib><contrib id="A5" contrib-type="author"><name><surname>Hearst</surname><given-names>Marti A</given-names></name><xref ref-type="aff" rid="I3">3</xref><email>hearst@sims.berkeley.edu</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Genetics, Stanford University, Stanford, CA, USA</aff><aff id="I2"><label>2</label>Computer Science Division, University of California, Berkeley, CA, USA</aff><aff id="I3"><label>3</label>School of Information Management &#x00026; Systems, University of California, Berkeley, CA, USA</aff><pub-date pub-type="collection"><year>2004</year></pub-date><pub-date pub-type="epub"><day>7</day><month>10</month><year>2004</year></pub-date><volume>5</volume><fpage>146</fpage><lpage>146</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/5/146"/><history><date date-type="received"><day>31</day><month>3</month><year>2004</year></date><date date-type="accepted"><day>7</day><month>10</month><year>2004</year></date></history><copyright-statement>Copyright &#x000a9; 2004 Oliver et al; licensee BioMed Central Ltd.</copyright-statement><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an open-access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p></license><abstract><sec><title>Background</title><p>Researchers who use MEDLINE for text mining, information extraction, or natural language processing may benefit from having a copy of MEDLINE that they can manage locally. The National Library of Medicine (NLM) distributes MEDLINE in eXtensible Markup Language (XML)-formatted text files, but it is difficult to query MEDLINE in that format. We have developed software tools to parse the MEDLINE data files and load their contents into a relational database. Although the task is conceptually straightforward, the size and scope of MEDLINE make the task nontrivial. Given the increasing importance of text analysis in biology and medicine, we believe a local installation of MEDLINE will provide helpful computing infrastructure for researchers.</p></sec><sec><title>Results</title><p>We developed three software packages that parse and load MEDLINE, and ran each package to install separate instances of the MEDLINE database. For each installation, we collected data on loading time and disk-space utilization to provide examples of the process in different settings. Settings differed in terms of commercial database-management system (IBM DB2 or Oracle 9i), processor (Intel or Sun), programming language of installation software (Java or Perl), and methods employed in different versions of the software. The loading times for the three installations were 76 hours, 196 hours, and 132 hours, and disk-space utilization was 46.3 GB, 37.7 GB, and 31.6 GB, respectively. Loading times varied due to a variety of differences among the systems. Loading time also depended on whether data were written to intermediate files or not, and on whether input files were processed in sequence or in parallel. Disk-space utilization depended on the number of MEDLINE files processed, amount of indexing, and whether abstracts were stored as character large objects or truncated.</p></sec><sec><title>Conclusions</title><p>Relational database (RDBMS) technology supports indexing and querying of very large datasets, and can accommodate a locally stored version of MEDLINE. RDBMS systems support a wide range of queries and facilitate certain tasks that are not directly supported by the application programming interface to PubMed. Because there is variation in hardware, software, and network infrastructures across sites, we cannot predict the exact time required for a user to load MEDLINE, but our results suggest that performance of the software is reasonable. Our database schemas and conversion software are publicly available at <ext-link ext-link-type="uri" xlink:href="http://biotext.berkeley.edu"/>.</p></sec></abstract></article-meta></front><body><sec><title>Background</title><p>MEDLINE is a large biomedical bibliographic database that is well known to users around the globe. It contains over 12 million citations from over 4,600 journals. MEDLINE is a rich source of biomedical text that lends itself well to research on text mining, information extraction, and natural language processing in biomedical domains. The usual way in which users query MEDLINE is through PubMed, the web-based interface and search engine provided by the National Library of Medicine (NLM) [<xref ref-type="bibr" rid="B1">1</xref>]. PubMed allows individuals to conduct searches directly by entering search terms on web pages and viewing results, and supports software-based queries across the Internet with programming utilities offered by the NLM [<xref ref-type="bibr" rid="B2">2</xref>]. Because we were interested in developing custom-made programs that query MEDLINE, the programming utilities offered by the NLM were an obvious choice to consider. However, due to risks of server overload, the NLM places limits on the number of queries that a user can send in a given time interval, and requests that large-volume queries be done on nights or weekends [<xref ref-type="bibr" rid="B3">3</xref>]. By contrast, a local version of MEDLINE gives software developers greater control over how they use the data, and facilitates the development of customizable interfaces. In this report, we describe the design and implementation of the database schema and database loading tools we have built to enable others to produce similar systems at their sites.</p><p>The entire content of MEDLINE is available as a set of text files formatted in XML (eXtensible Markup Language) [<xref ref-type="bibr" rid="B4">4</xref>]. The NLM distributes these files at no cost to the licensee, but the files are large and not easily searched without additional indexing and search tools. For example, in the 2003 release of MEDLINE, there are 396 files (which cover citations through 2002), and the total uncompressed size of these files is 40.8 gigabytes (GB). Although it is relatively inexpensive to store 40.8 GB of data, it is not easy to manipulate data of that magnitude without good software support. Relational databases are a natural choice for storing MEDLINE because they are able to handle large amounts of data, offer built-in approaches to query optimization, and enable the developer to create indexes. Additionally, the standard query language for relational databases, SQL (Structured Query Language), enjoys widespread familiarity and can be integrated with text-database queries in some commercial systems.</p><p>Alternatives to relational databases are XML-based databases, which have recently emerged as another option for storing information transmitted in XML format.XML databases may exist as standalone databases or as add-ons to relational systems. The MEDLINE data set would be an excellent test of the capabilities of these databases because of its size and complexity. We focused on relational databases because they are currently more ubiquitous and standardized, and interested users are more likely to be comfortable with relational database technology.</p><p>In the remainder of this report, we describe the software tools we developed for converting MEDLINE in XML files to MEDLINE in a relational database, and provide a few sample queries that demonstrate the flexibility of the resulting system.</p></sec><sec><title>Implementation</title><sec><title>Database schema</title><p>The NLM provides a DTD (Document Type Definition) that defines the structure of data in the MEDLINE XML files [<xref ref-type="bibr" rid="B5">5</xref>-<xref ref-type="bibr" rid="B7">7</xref>]. From this DTD, we designed a relational database schema. Although developers of MEDLINE at the NLM maintain their own version of MEDLINE in a relational database, the schema they use is not directly applicable to our purposes, because their implementation contains tables and data that are used for maintenance and that are not relevant to external users. Thus, it was appropriate for us to design our own schema based on the specific content of the XML files, as defined by the DTD. Other groups currently license the same MEDLINE XML files and may have implemented all of MEDLINE in a relational database, but if so, their database schemas are not well publicized and were not available.</p><p>There are multiple ways in which one can design a schema from the same DTD, because DTD elements and attributes can be mapped to tables and fields in different ways. Certain design decisions may favor speed at loading time, and others may favor speed and ease of use at query time. Loading records associated with 12 million citations into a database is very time consuming, and the time can be minimized if lookups to the database are minimized during loading. In general, we aimed to minimize lookups even if that meant repeating information in the database. As developers often do in the design of data warehouses, we chose to de-normalize the schema in order to improve read-only query performance, which is the typical data access pattern in our workload.</p><p>The typical table contains a PubMed identifier (PMID) in one column, and data related to that PMID in the remaining columns. Figures <xref ref-type="fig" rid="F1">1</xref> and <xref ref-type="fig" rid="F2">2</xref> show original representation of content from a portion of the DTD and a corresponding table that follows the typical table structure.</p><p>Our development team included a group of researchers from the University of California at Berkeley and another group from Stanford University. We shared similar goals in that we all wanted to load MEDLINE into a relational database, but because we were in two different departments at two different institutions, we had different project constraints and timelines. Thus, our groups were loosely associated in the software development process, but not closely integrated, and therefore, the original schema that we shared diverged.</p><p>The result was three MEDLINE schemas and three software variants: One schema was used with Java code developed at Berkeley, another schema was used with Berkeley's code modified to run at Stanford, and the third schema was used with Perl code developed at Stanford. Here we describe the underlying design that influenced all three of the schemas. (The schema used for the Java program did not include information from DTD elements DataBankList and AccessionNumberList. This has been corrected in the most recent version of the software available on the Berkeley website.)</p><p>The main table in the schema is <italic>medline_citation</italic>. The <italic>medline_citation </italic>table contains the PMID as the primary key and has additional columns that correspond to single-valued elements in the DTD, where the values of those elements depend on the PMID. The <italic>medline_abstract </italic>table is similar in that it has a PMID as the primary key and columns of data that depend on the PMID. Since document abstracts are larger than the other data types, we placed them in a separate table. However, since abstracts are stored as CLOBs (Character Large Objects), they are not stored in the same pages as the rest of the fields in the <italic>medline_abstract </italic>table. Therefore, in a more recent implementation, we removed the <italic>medline_abstract </italic>table from the schema, and added the <italic>abstract_text </italic>field as a CLOB in the <italic>medline_citation </italic>table. This change reduces the number of tables by one, and eliminates the need for a join between the <italic>medline_citation </italic>and <italic>medline_abstract </italic>tables.</p><p>Some tables in the schema have more than one row corresponding to the same PMID. Columns in these tables map to multi-valued elements in the DTD. Examples are the table <italic>medline_keyword_list</italic>, which stores multiple values of <italic>keyword </italic>for a given PMID, and <italic>medline_gene_symbol_list</italic>, which stores multiple values of <italic>gene_symbol </italic>for a given PMID.</p><p>The element <italic>Article </italic>in the DTD has a one-to-one relationship between an article and a PubMed identifier. Rather than giving <italic>Article </italic>its own table, we put single-valued data from <italic>Article </italic>into the table <italic>medline_citation</italic>.</p><p>To keep track of the name of the file from which data are read for a given citation, we added the field <italic>xml_file_name </italic>to the <italic>medline_citation </italic>table. This field does not correspond to any element in the DTD structure, but allows the database administrator to go back to the original XML file if necessary to find the original source of the data.</p><p>We could have stored each author only once in a table of its own, and assigned each author a unique integer primary key to serve as an author identifier. An author is represented by a combination of values in fields for last name, forename, first name, middle name, initials, suffix, affiliation, and collective name. Another table would have stored the set of author identifiers associated with each PMID, and because integer joins are fast, this design would have facilitated rapid search for all PMIDs associated with a given author, by joining the author table with the table of author identifiers and citations. However, there are several drawbacks to this approach. Generating integer primary keys during loading requires that either a lookup be done to see if each author of each citation already exists or not (35 million lookups), or all authors and primary keys must be kept in memory. The former approach is very time consuming during loading; the latter approach strains memory resources. In addition, regardless of how primary keys are managed during loading, it is not possible to determine algorithmically if two different representations of one author are actually the same author, or if one representation is actually two different authors. We therefore avoided generating unique primary keys and repeated all eight fields representing the author for every citation occurrence of that author.</p><p>Figure <xref ref-type="fig" rid="F3">3</xref> shows relationships among the tables. The table <italic>medline_journal </italic>is a parent of thirteen other tables (it contains the primary key <italic>pmid</italic>, which is used as a foreign key by the other tables). One of the other tables, <italic>medline_mesh_heading</italic>, is a parent of <italic>medline_mesh_heading_qualifier</italic>. Multiple qualifiers can be associated with each MeSH heading for a given citation.</p></sec><sec><title>Parsing and loading software</title><p>We implemented three versions of software that parses and loads MEDLINE. The first was Java MedlineParser, which was developed at Berkeley [see additional file 1]. The second was the same Java code, modified to run at Stanford. The third was Perl ParseMedline, which was developed at Stanford.</p><p>All versions of the software perform two basic tasks: (1) they parse the XML files to collect data, and (2) they load the data into the database. Figure <xref ref-type="fig" rid="F4">4</xref> shows the steps involved. Data can be loaded as they are collected, or can be written out to disk initially, and loaded later. All three versions offer these two options to the user. Document parsing is processor intensive, data insertion is disk intensive, and if needed, the two tasks can be executed at different times to accommodate other demands on the server.</p><p>There are two types of application programming interfaces (APIs) for parsing XML files &#x02013; the tree-based DOM (Document Object Model) and the event-based SAX (Simple API to XML) [<xref ref-type="bibr" rid="B8">8</xref>]. We chose the latter. A DOM parser organizes data from the XML file into a tree of nodes, and requires that the entire document be read in and stored in memory prior to writing out any data. Thus, the DOM parser is impractical for large documents whose data do not fit in memory. The SAX parser, however, receives data through a stream, and recognizes the beginning or end of a document, element, or attribute in an event-driven manner. It writes out data as it proceeds through the parsing process, and there is no need for the entire document to fit into memory. In XML MEDLINE, one document is a single XML-formatted MEDLINE file, and in the 2003 release, the majority of files range in size from 60 to 142 megabytes (MB). Using the DOM parser would put great demand on resources. In addition, the SAX parser is faster because it does not need to create an entire XML tree structure, map that structure to the program's data structures, and then throw out the original tree. Instead, it creates its own data structures as events are handled.</p><p>The Java version uses the Java SAX parser to parse the XML files, and JDBC (Java Database Connectivity) to communicate with the database. The Perl version uses the Perl SAX parser, and Perl DBI (Database Interface) to communicate with the database. We provide additional detail about the Java implementation here.</p><p>The SAX parser requires the developer to write code that specifies the data model for objects in the domain. The data model is an object model that represents tables in the schema. The SAX parser also requires code that listens for SAX events and that maps elements &#x02013; or nodes in the XML tree &#x02013; to the object model. We created two main classes upon which our code is based: GenericXMLParser and NodeHandler. GenericXMLParser is responsible for generating events when nodes that correspond to objects in the object model are encountered in the document, and NodeHandler provides the event listener. Together, these two classes form a generic approach to reading in XML data and writing out those data to tables; they are independent of the DTD or table structure.</p><p>As the parser processes the document, it decides how to handle the semantics of data at each node and determines whether to store parsed data at that node or to delegate the event to a child handler. For each node that corresponds to a table, there is a handler class that extends NodeHandler. A handler defines metadata for the node, and encodes any non-standard behavior at that node. An example of metadata is shown in Table <xref ref-type="table" rid="T1">1</xref>. Metadata include column names for the table and an XML element associated with each column name. An XML element is represented by a concatenation of the name of the element that holds the data value, and elements higher up in the element stack up to the node that corresponds to the object, or table. This concatenated name gives a unique representation of the element that holds the data. Finally, the data type is given for each column. The column names and data types match those specified in the database schema.</p><p>Since NodeHandler and GenericXMLParser are generic, they can be used to write similar parsers for other XML documents. We have, for example, used these classes to write a parser for MeSH (Medical Subject Headings) XML files, which are also distributed by the NLM. The MeSH files are small compared to MEDLINE. MeSH 2003 comes in three XML files that total less than 600 MB.</p><p>An optional feature is validation. XML files provided by the NLM are validly formatted, but we provide additional checks to ensure that all element tags in the XML data file have been handled by the parser and that all data have been inserted into the database. A developer who is extending the software to cover new tables can use this feature to ensure that metadata definitions are correct in classes that extend NodeHandler.</p></sec><sec><title>Choice of Relational Database Management Systems</title><p>In the course of our work, we applied the software tools we were developing to three different relational database products. Our Berkeley team initially experimented with PostgreSQL, since PostgreSQL is an open-source relational database and is freely available and modifiable. For the final implementation, however, we chose IBM's DB2 8.1 over PostgreSQL because we found that it could load our data more efficiently and because DB2 has a text-search extender. Our Stanford team used Oracle 9i, which like DB2, offers word-based indexing of text fields. Word-based indexing is essential to support keyword search of MEDLINE titles and abstracts.</p></sec><sec><title>Hardware configurations</title><p>At Berkeley, we used a Pentium IV Intel Xeon 2.00-GHz dual-processor system, with 1 GB of random access memory (RAM). It had an Integrated Drive Electronics (IDE) hard disk with a rotational speed of 7200 revolutions per minute (RPM). At Stanford, we used a Sun Fire V880 server configured with four 750-MHz processors, 8 GB of RAM, and storage-area-network (SAN) storage for the relational database. We also used a Sun Enterprise 3500 server with eight 400-MHz processors and 4 GB of RAM for reading input files and writing intermediate output files in the Perl version.</p></sec></sec><sec><title>Results and discussion</title><p>In this section, we describe loading time and disk-space utilization for the three implementations, followed by examples of queries, emphasizing differences between our system and PubMed.</p><p>The first implementation used the Java software, run on an Intel system (Linux), using IBM's DB2 database management system. The second implementation also used the Java software, run on a Sun server (SunOS), using Oracle's 9i database-management system. The third implementation used the Perl program, run on networked Sun servers, also using Oracle 9i. Table <xref ref-type="table" rid="T2">2</xref> summarizes our results.</p><sec><title>Loading time and disk space utilization</title><p>It took 76 hours (3 days and 4 hours) for the Berkeley group to run Java MedlineParser to load MEDLINE, and 196 hours (8 days and 4 hours) for the Stanford group to do so in Oracle. There were numerous differences between the two systems, and it was not possible to test each variable independently. Therefore, we present our data as a range of possibilities, and recognize that other users will have systems that are not the same as either of ours. We believe that differences in processor speed, memory, disk read-write efficiency, and optimization methods employed in commercial database-management systems may have affected loading times. In addition, the code diverged slightly after the initial transfer of code from Berkeley to Stanford, with the main difference being that the Berkeley version used CLOBs for abstracts, whereas the Stanford version used text fields truncated to 4000 characters (size limit imposed on VARCHAR datatype). The Stanford run was also slower because a log file was generated, whereas this feature was turned off in the Berkeley run.</p><p>The space requirement for the DB2 instance of MEDLINE at Berkeley was 46.3 GB, of which 10.4 GB are consumed by the abstract text CLOBs, 18.1 GB by the other tables, and 17.8 GB by indexes. The space requirement for the Oracle instance of MEDLINE at Stanford was 37.7 GB. The difference in size is primarily due to differences in the number of records that were loaded. The Berkeley group loaded data from XML files that included all of 2002 (early 2003 release) but also included additional files through April 2003. The Stanford group loaded data from 2002 XML files only. Berkeley parsed and loaded 500 input files (44.4 GB); Stanford parsed and loaded 396 input files (40.8 GB).</p><p>The Stanford group used Perl ParseMedline to load an additional instance of MEDLINE. Parsing and loading of this instance of the database took place in a two-stage process. In the first stage, Perl ParseMedline parsed the XML files and wrote the data to disk in comma-separated-value files. To reduce processing time, the 396 XML input files were divided into 8 sets of about 50 files each, and sets were processed in parallel. The maximum time required for processing one set was 31 hours (1 day and 7 hours). The output comma-separated-value files required 25.6 GB of disk space. In the second stage, the Stanford team loaded data from the comma-separated-value files into the Oracle database using SQL*Loader, a data loading tool provided by Oracle. This stage took 33 hours (1 day and 9 hours) and used 31.6 GB of space in the Oracle database. This version used less space than the other two primarily because it had less indexing and fewer key constraints. Relaxation of constraints is reasonable because the data are well curated by the NLM, and we can count on data in the XML files released by the NLM to be of high quality.</p><p>The total time required to parse and load the files in this two-stage process is the sum of the time required to parse the largest file if all files are processed in parallel (first stage) and the time required to load the resulting comma-separated-value files into the database (second stage). Alternatively, if the input files are parsed in series, the time for the first stage would be the sum of the input-file processing times. In our case, we overlapped the runs in a way that was convenient for us, given space and user constraints, and therefore mixed the parallel and serial approach. The overall time for our first stage was 99 hours (4 days and 3 hours); adding this time to the second stage gave a total time of 132 hours (5 days and 12 hours). Given the length of time to process each of our eight batches, we can estimate a lower limit of 64 hours (2 days and 16 hours), and an upper limit of 253 hours (10 days and 13 hours), if we had run the files completely in parallel or in series, respectively.</p></sec><sec><title>Sample queries</title><p>Certain queries that cannot be done easily through the PubMed application programming interface (API) can be done in a single SQL query to our relational database. In this section, we show the results of a several sample queries, run on a version of MEDLINE that contains citations through April 2003.</p><p>Timing data is presented in terms of "cold" caches and "warm" cache. The cold cache represents the worst case for timing, assuming the database server has just been restarted and the buffer pool is empty. The warm cache represents the best possible performance: running the same query a second time. A typical timing number should fall somewhere between the two; hence these times represent the range of expected times to run the sample queries.</p><p>A very simple query is one that retrieves all PMIDs in MEDLINE, where <italic>pmid </italic>is a column in table <italic>medline_citation </italic>(Table <xref ref-type="table" rid="T3">3</xref>).</p><p>Although typical users of PubMed would not be interested in such a query, we are managing MEDLINE as a complete database, and need to have access to all PMIDs. Running this query on the Berkeley implementation took 12 minutes and 26 seconds.</p><p>Many articles in MEDLINE are assigned terms from MeSH. Another capability of this system that distinguishes it from PubMed is the ability to rank order journals according to how many articles those journals have published that have been assigned a particular MeSH term. In the query shown below (Table <xref ref-type="table" rid="T4">4</xref>), the number of publications indexed with the MeSH term (or <italic>descriptor_name</italic>) "Leukemia" is shown for each journal (where <italic>medline_ta </italic>is the title abbreviation of a journal).</p><p>The result of this query is a table consisting of journals paired with number of publications (Table <xref ref-type="table" rid="T5">5</xref>); note that the query does not normalize for the fact that some journals have been publishing for more years than others, and publish more articles than others. This query ran in 4 minutes with a cold cache, and in 20 seconds with a warm cache.</p><p>SQL includes the "LIKE" operator which allows for partial matches. By modifying the query above to change the fifth line to read "WHERE msh.descriptor_name LIKE 'Leukemia%'," we change the query to match all MeSH terms that <italic>begin </italic>with "Leukemia". The query would thus include terms such as "Leukemia, Subleukemic" and "Leukemia, Feline." This results in dramatically more results, although the rank ordering is not all that different (Table <xref ref-type="table" rid="T6">6</xref>). This query ran in 4 minutes with a cold cache, and in 46 seconds with a warm cache.</p><p>MeSH terms are organized into a hierarchy, and each MeSH term has associated with it one or more descriptor tree numbers that indicate its place in the hierarchy. The Berkeley group developed additional code to parse MeSH XML data files (which can be downloaded from the NLM website [<xref ref-type="bibr" rid="B9">9</xref>]), and added MeSH tree data to the MEDLINE database. Using the additional functionality provided by the MeSH hierarchy, we can modify the query above to rank order journals according to how often they have articles that have been assigned the MeSH term under a certain tree number, thus eliminating the sensitivity to different spellings of related concepts that was shown in the queries above. In MeSH, a child tree number shares its leftmost digits with its parent tree number, and differs in its three rightmost digits Therefore, the SQL "LIKE" operator can be used to find a MeSH term and its descendants, as shown in the query below (Table <xref ref-type="table" rid="T7">7</xref>). The MeSH tree number for "Leukemia" is "C04.557.337".</p><p>The results of this query are shown in Table <xref ref-type="table" rid="T8">8</xref>.</p><p>This query ran in 4 minutes with a cold cache, and in 41 seconds with a warm cache.</p><p>The DB2 version of the system implementation makes use of the text index that is incorporated into the RDBMS system, using the operator "CONTAINS" which is not part of standard SQL. The following query asks how many papers in the last three years of MEDLINE have been published by authors with affiliations at Berkeley or Stanford (Table <xref ref-type="table" rid="T9">9</xref>).</p><p>This yields the results in Table <xref ref-type="table" rid="T10">10</xref>.</p><p>This query ran in 2.5 minutes with a cold cache, and in 7 seconds with a warm cache.</p><p>When we ran a similar query to determine the number of articles published by Berkeley, Stanford, MIT, Yale, and Harvard, the increase in time to run the query was minimal. This modified query ran in 3 minutes and 35 seconds with cold cache, and in 15 seconds with warm cache.</p><p>Thus, SQL makes it easy to quantify and rank order results, and does not require a post-processing step as would be necessary with queries to the PubMed API. Similarly, results retrieved from previous queries can be stored directly in the same database, and reused in later queries by simply joining MEDLINE tables with user-created tables. Again, the power of SQL may alleviate the need for a post-processing step. Instead of writing custom code to integrate results from the current query to PubMed with results from previous queries, the user could use SQL joins to integrate current and previous results.</p><p>Although our system offers capabilities that the PubMed API does not, we point out that PubMed offers functionality that is not available in our system. For example, the "Related Articles" feature found in PubMed is not available, and links to full text are not available. Also, PubMed provides a user interface that is more intuitive than SQL for an end user who is not a database expert, and will be preferred by users who simply want to look up an article.</p><p>The value of our system is that it offers greater flexibility for innovative software developers who want to experiment with novel techniques for searching biomedical text, and for system developers who want to build systems of which MEDLINE is a component. If such developers want to offer their systems to end users (e.g., biologists, clinicians, or the lay public), they will need to create more intuitive user interfaces. With direct access to the underlying database, developers can create interfaces that are specifically designed to serve the needs of their particular users.</p></sec></sec><sec><title>Conclusions</title><p>In this work, we developed highly customizable Java parsing code and a relational database schema that others may be interested in using or modifying. We developed software that uses the Java programming language and the SAX parser to parse XML-formatted MEDLINE files and load the data into a relational database. We loaded one copy into DB2 and another into Oracle, using our Java tool.</p><p>We also created a similar tool in Perl. The Perl code is less flexible and not as readily extensible as the object-oriented code of our Java software, but the functionality offered by the resulting database implementations is very similar.</p><p>Differences in loading time among the three installations of MEDLINE were due to a multiple factors, including differences in processors, disk storage devices, memory, operating systems, database-management systems, methods implemented in the software, and choices made by the user. Factors that affected disk-space utilization included the fact that one group loaded more data than the other, abstracts were stored as CLOBs at one site and as truncated text at the other, and indexes differed. Other groups will have system setups that differ from ours, and may make their own modifications to the code that affect their loading times. By presenting data on three examples, we have demonstrated a range of performance results as a guide to what other users might expect at their sites.</p><p>Future work includes adding functionality to update the system to new versions of MEDLINE, and to accommodate MEDLINE update files. The Stanford group has begun to use MEDLINE to extract drug-gene relationships from the literature, and the Berkeley group used the system, augmented with data from MeSH and LocusLink, to compete in the TREC 2003 genomics track competition [<xref ref-type="bibr" rid="B10">10</xref>]. As we continue to use these systems for research purposes, we are likely to identify alternative approaches that offer enhancements and improvements over the current design. We encourage others who work in similar areas to contribute to the open-source effort.</p><p>An updated version of our Java code accepts MEDLINE XML input files released in early 2004 that conform to the latest DTD (November 2003). The open-source code for this most current version of MedlineParser is available at <ext-link ext-link-type="uri" xlink:href="http://biotext.berkeley.edu"/>.</p></sec><sec><title>Availability and requirements</title><p>Project name: Java MedlineParser</p><p>Project web page: <ext-link ext-link-type="uri" xlink:href="http://biotext.berkeley.edu/software"/></p><p>Operating system: Platform independent</p><p>Programming language: Java</p><p>Other requirements: Java 1.4.1 or higher, JAXP, relational database, and JDBC driver appropriate for the particular target database</p><p>License: None</p><p>Any restrictions on use by non-academics: None</p><p>Project name: Perl ParseMEDLINE</p><p>Project web page: <ext-link ext-link-type="uri" xlink:href="http://biotext.berkeley.edu/software"/></p><p>Operating system: Platform independent</p><p>Programming language: Perl</p><p>Other requirements: Perl 5.8 or higher to handle MEDLINE Unicode data (if writing directly to database), or earlier version of Perl (if writing to comma-separated-value files first), Perl modules DBI and XML::Parser::PerlSAX, relational database, and Perl database driver appropriate for the particular database (e.g., DBD::Oracle)</p><p>License: None</p><p>Any restrictions on use by non-academics: None</p></sec><sec><title>Authors' contributions</title><p>DO, GB, and AS, developed the MEDLINE database schemas. GB and AS designed and implemented the Java MedlineParser. GB and AS ran MedlineParser to install MEDLINE in DB2 at Berkeley. DO ran MedlineParser to install MEDLINE in Oracle 9i at Stanford. DO developed Perl ParseMedline and ran it to install the second version of MEDLINE at Stanford. DO and GB were primary authors of the article, and the remaining authors added their contributions to the manuscript. MH supervised the work at Berkeley; RB supervised the work at Stanford.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>We thank Jane Rosov, John Butler, Tina Zhou, Leonard Brzezinski, Madhura Sharangpani, and John Conroy for useful discussions and assistance. Mark Musen and Teri Klein provided resources to support this work. Part of the research at Stanford was supported by NIH GM61374. The Berkeley portion of this research was supported by NSF DBI-0317510, an ARDA AQUAINT contract, and a gift from Genentech Corp.</p></sec></ack><ref-list><ref id="B1"><citation citation-type="other"><person-group person-group-type="author"><collab>NCBI</collab></person-group><article-title>PubMed Overview.</article-title><ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/entrez/query/static/overview.html"/></citation></ref><ref id="B2"><citation citation-type="other"><person-group person-group-type="author"><collab>NCBI</collab></person-group><article-title>Entrez Programming Utilities</article-title><ext-link ext-link-type="uri" xlink:href="http://eutils.ncbi.nlm.nih.gov/entrez/query/static/eutils_help.html"/></citation></ref><ref id="B3"><citation citation-type="other"><person-group person-group-type="author"><collab>NLM</collab></person-group><article-title>PubMed programming utilities user requirements</article-title><ext-link ext-link-type="uri" xlink:href="http://eutils.ncbi.nlm.nih.gov/entrez/query/static/eutils_help.html#UserSystemRequirements"/></citation></ref><ref id="B4"><citation citation-type="other"><person-group person-group-type="author"><collab>NLM</collab></person-group><article-title>Leasing data from the National Library of Medicine</article-title><ext-link ext-link-type="uri" xlink:href="http://www.nlm.nih.gov/databases/leased.html"/></citation></ref><ref id="B5"><citation citation-type="other"><person-group person-group-type="author"><collab>NLM</collab></person-group><article-title>NLM Medline DTD (Nov. 1, 2002)</article-title><ext-link ext-link-type="uri" xlink:href="http://www.nlm.nih.gov/databases/dtd/nlmmedline_021101.dtd"/></citation></ref><ref id="B6"><citation citation-type="other"><person-group person-group-type="author"><collab>NLM</collab></person-group><article-title>Medline Citation DTD (Nov. 1, 2002)</article-title><ext-link ext-link-type="uri" xlink:href="http://www.nlm.nih.gov/databases/dtd/nlmmedlinecitation_021101.dtd"/></citation></ref><ref id="B7"><citation citation-type="other"><person-group person-group-type="author"><collab>NLM</collab></person-group><article-title>NLMCommon DTD (Nov. 1, 2002)</article-title><ext-link ext-link-type="uri" xlink:href="http://www.nlm.nih.gov/databases/dtd/nlmcommon_021101.dtd"/></citation></ref><ref id="B8"><citation citation-type="other"><article-title>Events vs. Trees</article-title><ext-link ext-link-type="uri" xlink:href="http://www.saxproject.org/?selected=event"/></citation></ref><ref id="B9"><citation citation-type="other"><person-group person-group-type="author"><collab>NLM</collab></person-group><article-title>Medical Subject Headings - Files Available to Download</article-title><ext-link ext-link-type="uri" xlink:href="http://www.nlm.nih.gov/mesh/filelist.html"/></citation></ref><ref id="B10"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Bhalotia G</surname><given-names>Nakov PI, Schwartz AS, Hearst MA</given-names></name></person-group><article-title>BioText team report for the TREK 2003 Genomics Track</article-title><source>TREC Proceedings</source><year>2003</year></citation></ref></ref-list><sec sec-type="display-objects"><title>Figures and Tables</title><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Representation of information related to authors in the DTD. </bold>Selected portions of the DTD are shown. Database schema designers determine how entities and elements are converted to table names or field names in the database schema. See Figure 2 for the author table.</p></caption><graphic xlink:href="1471-2105-5-146-1"/></fig><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Representation of author information in the database schema. </bold>The typical table has a PubMed identifier (pmid) associated with other fields.</p></caption><graphic xlink:href="1471-2105-5-146-2"/></fig><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Dependencies in the database schema. </bold>Parent tables contain primary keys that child tables reference as foreign keys. The main table <italic>medline_citation</italic>, is a parent of thirteen other tables. The table <italic>medline_mesh_heading </italic>is a parent of <italic>medline_mesh_heading_qualifier</italic>.</p></caption><graphic xlink:href="1471-2105-5-146-3"/></fig><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>MEDLINE database development process. </bold>In Step 1, the user loads the schema, creating empty tables in the database. In Step 2, the conversion software parses the XML files and either loads the data directly into the database (2a), or writes the data out to intermediate text files (2b). If intermediate text files are generated, data from those files are loaded into the database as a separate step in Step 3.</p></caption><graphic xlink:href="1471-2105-5-146-4"/></fig><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Metadata for medline_author table.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left"><bold>columnNameDef</bold></td><td align="left"><bold>xmlElementNameDef</bold></td><td align="left"><bold>columnTypeDef</bold></td></tr></thead><tbody><tr><td align="left">pmid</td><td align="left">PMID</td><td align="left">Types.INTEGER</td></tr><tr><td align="left">last_name</td><td align="left">Author.LastName</td><td align="left">Types.VARCHAR</td></tr><tr><td align="left">fore_name</td><td align="left">Author.ForeName</td><td align="left">Types.VARCHAR</td></tr><tr><td align="left">first_name</td><td align="left">Author.FirstName</td><td align="left">Types.VARCHAR</td></tr><tr><td align="left">middle_name</td><td align="left">Author.MiddleName</td><td align="left">Types.VARCHAR</td></tr><tr><td align="left">initials</td><td align="left">Author.Initials</td><td align="left">Types.VARCHAR</td></tr><tr><td align="left">suffix</td><td align="left">Author.Suffix</td><td align="left">Types.VARCHAR</td></tr><tr><td align="left">affiliation</td><td align="left">Author.Affiliation</td><td align="left">Types.VARCHAR</td></tr><tr><td align="left">collective_name</td><td align="left">Author.CollectiveName</td><td align="left">Types.VARCHAR</td></tr></tbody></table><table-wrap-foot><p><bold><italic>columnNameDef</italic></bold>: column names for the table,</p><p><bold><italic>xmlElementNameDef</italic></bold>: XML element names that correspond to column names,</p><p><bold><italic>columnTypeDef</italic></bold>: data type of each column</p></table-wrap-foot></table-wrap><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Loading time and disk-space utilization.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">Site</td><td align="center">Language</td><td align="center">Processor</td><td align="center">Database</td><td align="center">Input Size</td><td align="center">Loading Time</td><td align="center">Disk Space</td></tr></thead><tbody><tr><td align="center">Berkeley</td><td align="center">Java</td><td align="center">Intel</td><td align="center">DB2</td><td align="center">44.4 GB (500 files)</td><td align="center">76 hours</td><td align="center">46.3 GB</td></tr><tr><td align="center">Stanford</td><td align="center">Java</td><td align="center">Sun</td><td align="center">Oracle</td><td align="center">40.8 GB (396 files)</td><td align="center">196 hours</td><td align="center">37.7 GB</td></tr><tr><td align="center">Stanford</td><td align="center">Perl</td><td align="center">Sun</td><td align="center">Oracle</td><td align="center">40.8 GB (396 files)</td><td align="center">132 hours</td><td align="center">31.6 GB</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T3"><label>Table 3</label><table frame="hsides" rules="groups"><tbody><tr><td align="left">SELECT pmid</td></tr><tr><td align="left">FROM medline_citation</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T4"><label>Table 4</label><table frame="hsides" rules="groups"><tbody><tr><td align="left">SELECT</td><td align="left">mc.medline_ta, count(mc.pmid) as num_of_publications</td></tr><tr><td align="left">FROM</td><td align="left">medline_citation mc</td></tr><tr><td></td><td align="left">JOIN medline_mesh_heading msh ON</td></tr><tr><td></td><td align="left">mc.pmid = msh.pmid</td></tr><tr><td align="left">WHERE</td><td align="left">msh.descriptor_name = 'Leukemia'</td></tr><tr><td align="left">GROUP BY</td><td align="left">mc.medline_ta</td></tr><tr><td align="left">ORDER BY</td><td align="left">count(mc.pmid) desc</td></tr><tr><td align="left">FETCH</td><td align="left">first 10 rows only;</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T5"><label>Table 5</label><table frame="hsides" rules="groups"><tbody><tr><td align="left">Blood</td><td align="left">940</td></tr><tr><td align="left">Cancer</td><td align="left">619</td></tr><tr><td align="left">Rinsho Ketsueki</td><td align="left">610</td></tr><tr><td align="left">Cancer Res</td><td align="left">588</td></tr><tr><td align="left">Br J Haematol</td><td align="left">524</td></tr><tr><td align="left">Bone Marrow Transplant</td><td align="left">520</td></tr><tr><td align="left">Lancet</td><td align="left">515</td></tr><tr><td align="left">Leuk Res</td><td align="left">476</td></tr><tr><td align="left">Leukemia</td><td align="left">463</td></tr><tr><td align="left">The N Engl J Med</td><td align="left">342</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T6"><label>Table 6</label><table frame="hsides" rules="groups"><tbody><tr><td align="left">Blood</td><td align="left">6721</td></tr><tr><td align="left">Cancer Res</td><td align="left">4653</td></tr><tr><td align="left">Leukemia</td><td align="left">4640</td></tr><tr><td align="left">Br J Haematol</td><td align="left">3918</td></tr><tr><td align="left">Leuk Res</td><td align="left">3061</td></tr><tr><td align="left">Cancer</td><td align="left">2772</td></tr><tr><td align="left">Rinsho Ketsueki</td><td align="left">2628</td></tr><tr><td align="left">Cancer Genet Cytogenet</td><td align="left">2192</td></tr><tr><td align="left">Bone Marrow Transplant</td><td align="left">2123</td></tr><tr><td align="left">Lancet</td><td align="left">1931</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T7"><label>Table 7</label><table frame="hsides" rules="groups"><tbody><tr><td align="left">SELECT</td><td align="left">mc.medline_ta, count(mc.pmid) as num_of_publications</td></tr><tr><td align="left">FROM</td><td align="left">medline_citation mc</td></tr><tr><td></td><td align="left">JOIN medline_mesh_heading msh ON</td></tr><tr><td></td><td align="left">mc.pmid = msh.pmid</td></tr><tr><td></td><td align="left">JOIN mesh_descriptor md ON</td></tr><tr><td></td><td align="left">md.descriptor_name = msh.descriptor_name</td></tr><tr><td></td><td align="left">JOIN mesh_desc_tree_number mdtn ON</td></tr><tr><td></td><td align="left">md.descriptor_ui = mdtn.descriptor_ui</td></tr><tr><td align="left">WHERE</td><td align="left">mdtn.tree_number LIKE 'C04.557.337%'</td></tr><tr><td align="left">GROUP BY</td><td align="left">mc.medline_ta</td></tr><tr><td align="left">ORDER BY</td><td align="left">count(mc.pmid) desc</td></tr><tr><td align="left">FETCH</td><td align="left">first 10 rows only;</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T8"><label>Table 8</label><table frame="hsides" rules="groups"><tbody><tr><td align="left">Blood</td><td align="left">7361</td></tr><tr><td align="left">Leukemia</td><td align="left">5168</td></tr><tr><td align="left">Cancer Res</td><td align="left">4595</td></tr><tr><td align="left">Br J Haematol</td><td align="left">4249</td></tr><tr><td align="left">Leuk Res</td><td align="left">3274</td></tr><tr><td align="left">Cancer</td><td align="left">2856</td></tr><tr><td align="left">Rinsho Ketsueki</td><td align="left">2789</td></tr><tr><td align="left">Cancer Genet Cytogenet</td><td align="left">2362</td></tr><tr><td align="left">Leuk Lymph</td><td align="left">2226</td></tr><tr><td align="left">Bone Marrow Transplant</td><td align="left">2183</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T9"><label>Table 9</label><table frame="hsides" rules="groups"><tbody><tr><td align="left">SELECT</td><td align="left">'Berkeley' as institution, count(pmid) as num_of_publications</td></tr><tr><td align="left">FROM</td><td align="left">medline_citation</td></tr><tr><td align="left">WHERE</td><td align="left">CONTAINS(article_affiliation,'"Berkeley"') = 1</td></tr><tr><td align="left">AND</td><td align="left">date_created &#x0003e; current date &#x02013; 3 years</td></tr><tr><td align="left">UNION</td><td></td></tr><tr><td align="left">SELECT</td><td align="left">'Stanford' as institution, count(pmid) as num_of_publications</td></tr><tr><td align="left">FROM</td><td align="left">medline_citation</td></tr><tr><td align="left">WHERE</td><td align="left">CONTAINS(article_affiliation,'"Stanford"') = 1</td></tr><tr><td align="left">AND</td><td align="left">date_created &#x0003e; current date &#x02013; 3 years;</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T10"><label>Table 10</label><table frame="hsides" rules="groups"><tbody><tr><td align="left">Berkeley</td><td align="left">2623</td></tr><tr><td align="left">Stanford</td><td align="left">4226</td></tr></tbody></table></table-wrap></sec></back></article>



