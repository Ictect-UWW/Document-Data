<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="product-review"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">15667658</article-id><article-id pub-id-type="pmc">PMC552317</article-id><article-id pub-id-type="publisher-id">1471-2105-6-16</article-id><article-id pub-id-type="doi">10.1186/1471-2105-6-16</article-id><article-categories><subj-group subj-group-type="heading"><subject>Software</subject></subj-group></article-categories><title-group><article-title>Efficient decoding algorithms for generalized hidden Markov model gene finders</article-title></title-group><contrib-group><contrib id="A1" corresp="yes" contrib-type="author"><name><surname>Majoros</surname><given-names>William H</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>bmajoros@tigr.org</email></contrib><contrib id="A2" contrib-type="author"><name><surname>Pertea</surname><given-names>Mihaela</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>mpertea@tigr.org</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Delcher</surname><given-names>Arthur L</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>adelcher@tigr.org</email></contrib><contrib id="A4" contrib-type="author"><name><surname>Salzberg</surname><given-names>Steven L</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>salzberg@tigr.org</email></contrib></contrib-group><aff id="I1"><label>1</label>Bioinformatics Department, The Institute for Genomic Research, 9712 Medical Center Drive, Rockville, MD, USA</aff><pub-date pub-type="collection"><year>2005</year></pub-date><pub-date pub-type="epub"><day>24</day><month>1</month><year>2005</year></pub-date><volume>6</volume><fpage>16</fpage><lpage>16</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/6/16"/><history><date date-type="received"><day>15</day><month>11</month><year>2004</year></date><date date-type="accepted"><day>24</day><month>1</month><year>2005</year></date></history><copyright-statement>Copyright &#x000a9; 2005 Majoros et al; licensee BioMed Central Ltd.</copyright-statement><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p></license><abstract><sec><title>Background</title><p>The Generalized Hidden Markov Model (GHMM) has proven a useful framework for the task of computational gene prediction in eukaryotic genomes, due to its flexibility and probabilistic underpinnings. As the focus of the gene finding community shifts toward the use of homology information to improve prediction accuracy, extensions to the basic GHMM model are being explored as possible ways to integrate this homology information into the prediction process. Particularly prominent among these extensions are those techniques which call for the simultaneous prediction of genes in two or more genomes at once, thereby increasing significantly the computational cost of prediction and highlighting the importance of speed and memory efficiency in the implementation of the underlying GHMM algorithms. Unfortunately, the task of implementing an efficient GHMM-based gene finder is already a nontrivial one, and it can be expected that this task will only grow more onerous as our models increase in complexity.</p></sec><sec><title>Results</title><p>As a first step toward addressing the implementation challenges of these next-generation systems, we describe in detail two software architectures for GHMM-based gene finders, one comprising the common array-based approach, and the other a highly optimized algorithm which requires significantly less memory while achieving virtually identical speed. We then show how both of these architectures can be accelerated by a factor of two by optimizing their content sensors. We finish with a brief illustration of the impact these optimizations have had on the feasibility of our new homology-based gene finder, TWAIN.</p></sec><sec><title>Conclusions</title><p>In describing a number of optimizations for GHMM-based gene finders and making available two complete open-source software systems embodying these methods, it is our hope that others will be more enabled to explore promising extensions to the GHMM framework, thereby improving the state-of-the-art in gene prediction techniques.</p></sec></abstract></article-meta></front><body><sec><title>Background</title><p>Generalized Hidden Markov Models have seen wide use in recent years in the field of computational gene prediction. A number of <italic>ab initio </italic>gene-finding programs are now available which utilize this mathematical framework internally for the modeling and evaluation of gene structure [<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B6">6</xref>], and newer systems are now emerging which expand this framework by simultaneously modeling two genomes at once, in order to harness the mutually informative signals present in homologous gene structures from recently diverged species. As greater numbers of such genomes become available, it is tempting to consider the possibility of integrating all this information into increasingly complex models of gene structure and evolution.</p><p>Notwithstanding our eagerness to utilize this expected flood of genomic data, methods have yet to be demonstrated which can perform such large-scale parallel analyses without requiring inordinate computational resources. In the case of Generalized Pair HMMs (GPHMMs), for example, the only systems in existence of which we are familiar make a number of relatively restrictive assumptions in order to reduce the computational complexity of the problem to a more tolerable level [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B15">15</xref>]. Yet, even these systems are currently capable of handling no more than two genomes at once. If larger numbers of genomes are to be simultaneously integrated into the gene prediction process in a truly useful manner, then it is reasonable to suggest that new methods will be needed for efficient modeling of parallel gene structures and their evolution. Assuming for now that these methods are likely to continue to build on the basic GHMM framework, we feel it is important that efficient methods of GHMM implementation be properly disseminated for the benefit of those who are to work on this next generation of eukaryotic gene finders.</p><sec><title>Modeling genes with a GHMM</title><p>A Hidden Markov Model (HMM) is a state-based generative model which transitions stochastically from state to state, emitting a single symbol from each state. A GHMM (or <italic>semi-Markov </italic>model) generalizes this scenario by allowing individual states to emit strings of symbols rather than one symbol at a time [<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B10">10</xref>]. A GHMM is parameterized by its transition probabilities, its state duration (i.e., feature length) probabilities, and its state emission probabilities. These probabilities influence the behavior of the model in terms of which sequences are most likely to be emitted and which series of states are most likely to be visited by the model as it generates its output.</p><p>Eukaryotic gene prediction entails the parsing of a DNA sequence into a set of putative CDSs (<italic>coding segments</italic>, hereafter referred to informally as "genes") and their corresponding exon-intron structures [<xref ref-type="bibr" rid="B11">11</xref>]. Thus, the problem of eukaryotic gene prediction can be approximately stated as one of parsing sequences over the nucleotide alphabet &#x003a3; = {A,C,G,T} according to the regular expression:</p><p>&#x003a3;*(<underline>ATG</underline>&#x003a3;*(<underline>GT</underline>&#x003a3;*<underline>AG</underline>)*&#x003a3;*<underline>&#x00393;</underline>)*&#x003a3;*, &#x000a0;&#x000a0;&#x000a0; (1)</p><p>where the <italic>signals </italic>(start and stop codons, donors, and acceptors) have been underlined for clarity, and where &#x00393; = {TAG,TGA,TAA} represents a stop codon. (The actual nucleotides comprising these signals may differ between organisms; we have given the most common ones). An additional constraint not explicitly represented in Formula 1 is that the number of non-intron nucleotides between the start and stop codons of a single gene must be a multiple of three, and furthermore, if these nucleotides are aggregated into a discrete number of nonoverlapping triples, or <italic>codons</italic>, then none of these codons must be a stop codon, other than the stop codon which terminates the gene. Note that the &#x003a3;* terms in Formula 1 permit the occurrence of <italic>pseudo-signals </italic>&#x02013; e.g., an ATG triple which does not comprise a true start codon. Gene prediction with a GHMM thus entails parsing with an ambiguous stochastic regular grammar; the challenge is to find the most probable parse of an input sequence, given the GHMM parameters and the input sequence.</p><p>In the case of simple Hidden Markov Models, this optimal parsing (or <italic>decoding</italic>) problem can be solved with the well-known <italic>Viterbi algorithm</italic>, a dynamic programming algorithm with run time linear in the sequence length (for a fixed number of states) [<xref ref-type="bibr" rid="B12">12</xref>]. A modified Viterbi algorithm is required in the case of GHMMs, since each state can now emit more than one symbol at a time [<xref ref-type="bibr" rid="B2">2</xref>], resulting in the following optimization problem:</p><p><inline-graphic xlink:href="1471-2105-6-16-i1.gif"/></p><p>where &#x003c6; is a <italic>parse </italic>of the sequence consisting of a series of states <italic>q</italic><sub><italic>i </italic></sub>and state durations <italic>d</italic><sub><italic>i</italic></sub>, 0&#x02264;<italic>i</italic>&#x02264;<italic>n</italic>, with each state <italic>q</italic><sub><italic>i </italic></sub>emitting subsequence <italic>S</italic><sub><italic>i </italic></sub>of length <italic>d</italic><sub><italic>i</italic></sub>, so that the concatenation of all <italic>S</italic><sub>0</sub><italic>S</italic><sub>1</sub>...<italic>S</italic><sub><italic>n </italic></sub>produces the complete output sequence <italic>S </italic>(but note that states <italic>q</italic><sub>0 </sub>and <italic>q</italic><sub><italic>n </italic></sub>are <italic>silent</italic>, producing no output). <italic>P</italic><sub><italic>e</italic></sub>(<italic>S</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic></sub>,<italic>d</italic><sub><italic>i</italic></sub>) denotes the probability that state <italic>q</italic><sub><italic>i </italic></sub>emits subsequence <italic>S</italic><sub><italic>i</italic></sub>, given duration <italic>d</italic><sub><italic>i</italic></sub>; <italic>P</italic><sub><italic>t</italic></sub>(<italic>q</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic>-1</sub>) is the probability that the GHMM transitions from state <italic>q</italic><sub><italic>i</italic>-1 </sub>to state <italic>q</italic><sub><italic>i</italic></sub>; and <italic>P</italic><sub><italic>d</italic></sub>(<italic>d</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic></sub>) is the probability that state <italic>q</italic><sub><italic>i </italic></sub>has duration <italic>d</italic><sub><italic>i</italic></sub>. The <italic>argmax </italic>is over all parses of the DNA sequence into well-formed exon-intron structures; hence, the problem is one of finding the parse which maximizes the product in Equation 2.</p></sec></sec><sec><title>Implementation</title><sec><title>The PSA decoding algorithm</title><p>The approach commonly used in GHMM gene finders for evaluating Equation 2 is to allocate several arrays, one per variable-length feature state, and to evaluate the arrays left-to-right along the length of the input sequence according to a dynamic programming algorithm, which we will detail below. We refer to this approach as the <italic>Prefix Sum Arrays </italic>(PSA) approach, since the values in the aforementioned arrays represent cumulative scores for prefixes of the sequence.</p><p>Without loss of generality, let us consider the GHMM structure depicted in Figure <xref ref-type="fig" rid="F1">1</xref>. Although individual GHMMs will differ from this particular structure on specific points, the model in Figure <xref ref-type="fig" rid="F1">1</xref> is general enough to serve as a concrete example as we illustrate the operation of the algorithm.</p><p>The diamonds denote the states for fixed length features (ATG = start codon, TAG = stop codon, GT = donor, AG = acceptor) and the circles denote states for variable length features (N = intergenic, I = intron, E<sub>sng </sub>= single exon, E<sub>init </sub>= initial exon, E<sub>int </sub>= internal exon, E<sub>fin </sub>= final exon). This model generates genes only on the forward strand of the DNA; to obtain a double-stranded model one can simply mirror the structure and link the forward and reverse models through a single merged intergenic state.</p><p>Associated with each diamond state is a <italic>signal sensor </italic>such as a <italic>weight matrix </italic>(WMM) or some other fixed-length model (e.g., a WAM, WWAM, MDD tree, etc.) [<xref ref-type="bibr" rid="B13">13</xref>], and with each circular state is associated a variable-length <italic>content sensor</italic>, such as a <italic>Markov chain </italic>(MC) or an <italic>Interpolated Markov Model </italic>(IMM) [<xref ref-type="bibr" rid="B14">14</xref>].</p><p>For the purposes of illustration, we will consider only the simplest of each model type, since the more complex model types commonly in use can in general be handled generically within the GHMM framework. The simplest fixed-length model is the WMM:</p><p><inline-graphic xlink:href="1471-2105-6-16-i2.gif"/></p><p>where <italic>x</italic><sub><italic>h</italic></sub>..<italic>x</italic><sub><italic>h</italic>+<italic>n </italic></sub>denotes the subsequence currently within a sliding (<italic>n </italic>+ 1)-element window, called the <italic>context window</italic>, and <italic>P</italic>(<italic>x</italic>|&#x003b8;[<italic>i</italic>]) denotes the probability of nucleotide <italic>x </italic>occurring at position <italic>i </italic>within the window, for model &#x003b8;. In practice, all of the probabilities described in all of these models are represented in log space (to reduce the incidence of numerical underflow on the computer), so that products of probabilities can be replaced with sums of their logs.</p><p>The simplest variable-length model used in practice is the Markov chain. An <italic>n</italic><sup>th</sup>-order Markov chain <italic>M </italic>for state <italic>q</italic><sub><italic>i </italic></sub>would evaluate the probability <italic>P</italic>(<italic>S</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic></sub>,<italic>d</italic><sub><italic>i</italic></sub>) of a putative feature <italic>S</italic><sub><italic>i </italic></sub>according to:</p><p><inline-graphic xlink:href="1471-2105-6-16-i3.gif"/></p><p>where <italic>x</italic><sub><italic>j </italic></sub>is the <italic>j</italic><sup>th </sup>nucleotide in the sequence of the putative feature, <italic>d</italic><sub><italic>i </italic></sub>is the length of that feature, and <italic>P</italic><sub><italic>M</italic></sub>(<italic>x</italic><sub><italic>j</italic></sub>|<italic>x</italic><sub><italic>j</italic>-<italic>n</italic></sub>..<italic>x</italic><sub><italic>j</italic>-1</sub>) is the probability of nucleotide <italic>x</italic><sub><italic>j </italic></sub>conditional on the identities of its <italic>n </italic>predecessor nucleotides, according to <italic>content model M</italic>. As with the fixed-length model described above, this computation is typically done in log space.</p><p>In scoring the signals and content regions of a putative gene parse, it will be important for us to carefully differentiate between the nucleotides which are scored by a signal sensor and those which are scored by a content sensor in a putative parse. As shown in Figure <xref ref-type="fig" rid="F2">2</xref>, the content and signal regions must partition the sequence into non-overlapping segments; allowing overlaps would result in double-counting of nucleotide probabilities, which can lead to undesirable biases in the decoding algorithm.</p><p>The first step of the PSA algorithm is to compute a prefix sum array for each content sensor. For noncoding states (introns and intergenic) this can be formalized as shown in Figure <xref ref-type="fig" rid="F3">3</xref>.</p><p>In the case of exon states, it is important to capture the different statistical properties present in the three codon positions, referred to as <italic>phase 0</italic>, <italic>phase 1</italic>, and <italic>phase 2</italic>. We employ three Markov chains, <italic>M</italic><sub>0</sub>, <italic>M</italic><sub>1</sub>, and <italic>M</italic><sub>2</sub>, corresponding to these three phases. Together, these three chains constitute a <italic>three-periodic Markov chain</italic>, <italic>M</italic><sub>{0,1,2}</sub>. Exon states then require three arrays, each of which can be initialized using the procedure shown in Figure <xref ref-type="fig" rid="F4">4</xref>.</p><p>In this way, we can initialize the three arrays &#x003b1;<sub>i, 0</sub>, &#x003b1;<sub>i, 1</sub>, and &#x003b1;<sub>i, 2 </sub>for an exon state <italic>q</italic><sub><italic>i </italic></sub>as follows:</p><p><bold>for </bold>&#x003c9; &#x02190; 0 <bold>to </bold>2 <bold>do</bold></p><p>&#x000a0;&#x000a0;&#x000a0;init_phased(&#x003b1;<sub>i,&#x003c9;</sub>, S, M<sub>{0, 1, 2}</sub>,&#x003c9;) ;</p><p>The individual chains <italic>M</italic><sub>0</sub>, <italic>M</italic><sub>1</sub>, and <italic>M</italic><sub>2 </sub>comprising <italic>M</italic><sub>{0,1,2} </sub>are applied in periodic fashion within the procedure init_phased() to compute conditional probabilities of successive nucleotides along the length of the array. The three arrays are phase-shifted by one from each other, with each element in the array storing the cumulative score of the prefix up to the current nucleotide. The first nucleotide is taken to be in phase &#x003c9; for array &#x003b1;<sub><italic>i</italic></sub>,&#x003c9;. Initializing the arrays for reverse-strand states can be achieved by simply reverse-complementing the DNA sequence and then reversing the order of the resulting arrays (keeping in mind later that the reverse-strand arrays tabulate their sums from the right, rather than the left, and that &#x003c9; is the phase of the last array entry rather than the first).</p><p>Once the prefix sum arrays have been initialized for all variable-duration states, we make another left-to-right pass over the input sequence to look for all possible matches to the fixed-length states, via the signal sensors. In general, a signal sensor &#x003b8; models the statistical biases of nucleotides at fixed positions surrounding a signal of a given type, such as a start codon. Whenever an appropriate consensus is encountered (such as ATG for the start codon sensor), the signal sensor's fixed-length window is superimposed around the putative signal (i.e., with a margin of zero or more nucleotides on either side of the signal consensus) and evaluated to produce a logarithmic signal score <italic>R</italic><sub><italic>S </italic></sub>= <bold>log </bold><italic>P</italic>(<italic>x</italic><sub><italic>h</italic>..</sub><italic>x</italic><sub><italic>h</italic>+<italic>n</italic>-1</sub>|&#x003b8;), where <italic>h </italic>is the position of the beginning of the window and <italic>n </italic>is the window length. If signal <italic>thresholding </italic>is desired, <italic>R</italic><sub><italic>S </italic></sub>can be compared to a pre-specified threshold and those locations scoring below the threshold can be eliminated from consideration as putative signals.</p><p>The remaining candidates for signals of each type are then inserted into a type-specific <italic>signal queue </italic>for consideration later as possible predecessors of subsequent signals in a putative gene model. As each new signal is encountered, the optimal predecessors for the signal are selected from among the current contents of the signal queues, using a scoring function described below. In the example (forward strand) GHMM depicted in Figure <xref ref-type="fig" rid="F1">1</xref>, the possible (predecessor&#x02192;successor) patterns are:</p><p>ATG&#x02192;TAG</p><p>ATG&#x02192;GT</p><p>GT&#x02192;AG</p><p>AG&#x02192;GT</p><p>AG&#x02192;TAG</p><p>TAG&#x02192;ATG</p><p>Associated with each of these patterns is a transition probability, <italic>P</italic><sub><italic>t</italic></sub>(<italic>q</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic>-1</sub>), which is included in the scoring of a possible predecessor; this probability can be accessed quickly by indexing into a two-dimensional array. The logarithmic transition score will be denoted <italic>R</italic><sub><italic>T</italic></sub>(<italic>q</italic><sub><italic>i</italic>-1</sub>,<italic>q</italic><sub><italic>i</italic></sub>) = <bold>log </bold><italic>P</italic><sub><italic>t</italic></sub>(<italic>q</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic>-1</sub>).</p><p>The distance from a prospective predecessor to the current signal is also included in the evaluation in the form of <italic>P</italic><sub><italic>d</italic></sub>(<italic>d</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic></sub>) for distance (=duration) <italic>d</italic><sub><italic>i </italic></sub>and signal type (=state) <italic>q</italic><sub><italic>i</italic></sub>. This probability can usually be obtained relatively quickly, depending on the representation of the duration distributions. If the distributions have been fitted to a curve with a simple algebraic formula, then evaluation of the formula is typically a constant-time operation. If a histogram is instead maintained, then a binary search is typically required to find the histogram interval containing the given distance. We denote the logarithmic duration score <italic>R</italic><sub><italic>D</italic></sub>(<italic>q</italic><sub><italic>i</italic></sub>,<italic>q</italic><sub><italic>j</italic></sub>) = <bold>log </bold><italic>P</italic><sub><italic>d</italic></sub>(<italic>d</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic>:<italic>j</italic></sub>) where <italic>d</italic><sub><italic>i </italic></sub>is the length of the content region delimited by signals <italic>q</italic><sub><italic>i </italic></sub>and <italic>q</italic><sub><italic>j</italic></sub>, and <italic>q</italic><sub><italic>i</italic>:<italic>j </italic></sub>is the variable-length state corresponding to that content region.</p><p>Following Equation 2, the final component of the scoring function is the emission probability <italic>P</italic><sub><italic>e</italic></sub>(<italic>S</italic><sub><italic>i</italic></sub>|<italic>q</italic><sub><italic>i</italic></sub>,<italic>d</italic><sub><italic>i</italic></sub>). For a fixed-length state, this is simply the score produced by the signal sensor. For a variable-length state <italic>q</italic><sub><italic>i</italic></sub>, <italic>P</italic><sub><italic>e </italic></sub>can be evaluated very quickly by indexing into the prefix sum array &#x003b1;<sub><italic>i</italic>,&#x003b3; </sub>for state <italic>q</italic><sub><italic>i </italic></sub>and phase &#x003b3; at the appropriate indices for the two signals and simply performing subtraction:</p><p><italic>R</italic><sub><italic>C</italic></sub>(<italic>s</italic><sub>pred</sub>,<italic>s</italic><sub>cur</sub>,&#x003c9;) &#x02190; &#x003b1;<sub><italic>i</italic>,&#x003b3; </sub>[<italic>wpos</italic>(<italic>s</italic><sub>cur</sub>) - 1] - &#x003b1;<sub><italic>i</italic>,&#x003b3; </sub>[<italic>wpos</italic>(<italic>s</italic><sub>pred</sub>) + <italic>wlen</italic>(<italic>s</italic><sub>pred</sub>) - 1], &#x000a0;&#x000a0;&#x000a0; (5)</p><p>where <italic>wpos</italic>(<italic>s</italic>) is the 0-based position (within the full input sequence) of the first nucleotide in the context window for signal <italic>s</italic>, <italic>wlen</italic>(<italic>s</italic>) is the length of the context window for signal <italic>s</italic>, and <italic>s</italic><sub>pred </sub>and <italic>s</italic><sub>cur </sub>are the predecessor and current signals, respectively. In the case of coding features, &#x003b3; is the phase of the array and &#x003c9; = (&#x003b3; + <italic>pos</italic>(<italic>s</italic><sub>cur</sub>))<bold>mod</bold>3 is the phase of <italic>s</italic><sub>cur</sub>, for <italic>pos</italic>(<italic>s</italic><sub>cur</sub>) the position of the leftmost consensus base of <italic>s</italic><sub>cur</sub>. For reverse-strand features, since the prefix sum arrays tabulate their sums from the right instead of the left, the subtraction must be reversed:</p><p><italic>R</italic><sub><italic>C</italic></sub>(<italic>s</italic><sub>pred</sub>,<italic>s</italic><sub>cur</sub>,&#x003c9;) &#x02190; &#x003b1;<sub><italic>i</italic>,&#x003b3;</sub>[<italic>wpos</italic>(<italic>s</italic><sub>pred</sub>) + <italic>wlen</italic>(<italic>s</italic><sub>pred</sub>)] - &#x003b1;<sub><italic>i</italic>,&#x003b3;</sub>[<italic>wpos</italic>(<italic>s</italic><sub>cur</sub>)], &#x000a0;&#x000a0;&#x000a0; (6)</p><p>and &#x003c9; = (&#x003b3; +<italic>L </italic>- <italic>pos</italic>(<italic>s</italic><sub>cur</sub>) - 1)<bold>mod</bold>3, for <italic>L </italic>the sequence length. For noncoding features, the phases can be ignored when computing <italic>R</italic><sub><italic>C</italic></sub>, since there is only one array per noncoding state.</p><p>The resulting optimization function is:</p><p><inline-graphic xlink:href="1471-2105-6-16-i4.gif"/></p><p>for current signal <italic>s</italic><sub><italic>j </italic></sub>and predecessor signal <italic>s</italic><sub><italic>i</italic></sub>; <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003b3;<sub><italic>i</italic></sub>) denotes the logarithmic inductive score for signal <italic>s</italic><sub><italic>i </italic></sub>in phase &#x003b3;<sub><italic>i</italic></sub>. For forward-strand coding features, the phases &#x003b3;<sub><italic>i </italic></sub>and &#x003b3;<sub><italic>j </italic></sub>are related by:</p><p>&#x003b3;<sub><italic>i </italic></sub>= (&#x003b3;<sub><italic>j </italic></sub>- &#x00394;)<bold>mod</bold>3, &#x000a0;&#x000a0;&#x000a0; (8)</p><p>for &#x00394; the putative exon length, or, equivalently,</p><p>&#x003b3;<sub><italic>j </italic></sub>= (&#x003b3;<sub><italic>i </italic></sub>+ &#x00394;)<bold>mod</bold>3. &#x000a0;&#x000a0;&#x000a0; (9)</p><p>These relations can be converted to the reverse strand by swapping + and -. For introns, &#x003b3;<sub><italic>i </italic></sub>= &#x003b3;<sub><italic>j</italic></sub>. For intergenic features, the phase will always be 0 for a forward strand signal and 2 for a reverse strand signal (since on the reverse strand the leftmost base of a 3-base signal would be in phase 2).</p><p>The result of Equation 7 is the optimal predecessor for signal <italic>s</italic><sub><italic>j</italic></sub>. This scoring function is evaluated for all appropriate predecessor signals, which are readily available in one or more queues, as mentioned above. A pointer called a <italic>trellis link </italic>is then created, pointing from the current signal to its optimal predecessor. In the case of those signals that can terminate an exon or an intron, three optimal predecessors must be retained, one for each phase. The inductive score <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>,&#x003b3;<sub><italic>j</italic></sub>) of the new signal <italic>s</italic><sub><italic>j </italic></sub>is then initialized from the selected predecessor <italic>s</italic><sub><italic>i </italic></sub>as follows:</p><p><italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>, &#x003b3;<sub><italic>j</italic></sub>) &#x02190; <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>, &#x003b3;<sub><italic>j</italic></sub>) + <italic>R</italic><sub><italic>T</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>, <italic>s</italic><sub><italic>j</italic></sub>) + <italic>R</italic><sub><italic>D</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>, <italic>s</italic><sub><italic>j</italic></sub>) + <italic>R</italic><sub><italic>C</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>, <italic>s</italic><sub><italic>j</italic></sub>, &#x003b3;<sub><italic>j</italic></sub>) + <italic>R</italic><sub><italic>S</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>), &#x000a0;&#x000a0;&#x000a0; (10)</p><p>where <italic>R</italic><sub><italic>S</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>) is the logarithmic score produced by the signal sensor for signal <italic>s</italic><sub><italic>j</italic></sub>.</p><p>A final step to be performed at each position along the input sequence is to drop from each queue any signal that has been rendered unreachable from all subsequent positions due to intervening stop codons. Except for the final stop codon of a gene, <italic>in-phase </italic>(i.e., in phase 0) stop codons are generally not permitted in coding exons; for this reason, any potential stop codon (regardless of its signal score) will eclipse any preceding start codon or acceptor site (or, on the reverse strand, stop codon or donor site) in the corresponding phase. The algorithm shown in Figure <xref ref-type="fig" rid="F5">5</xref> addresses this issue by dropping any fully eclipsed signal (i.e., eclipsed in all three phases) from its queue.</p><p>For the reverse strand, line 3 of eclipse() should be changed to:</p><p>&#x003c9; &#x02190; (p-pos(s)-len(s) - 1) <bold>mod</bold>3;</p><p>where len(s) is the length of the consensus sequence for signal s (e.g., 3 for ATG). Note that by x<bold>mod</bold>3 we mean the <italic>positive </italic>remainder after division of x by 3; in some programming languages (such as C/C++), a negative remainder may be returned, in which case 3 should be added to the result.</p><p>A special case of eclipsing which is not handled by eclipse() is that which occurs when a stop codon straddles an intron; this can be handled fairly simply by checking for such when considering each donor signal as a prospective predecessor for an acceptor signal (or vice-versa on the reverse strand). As each predecessor is evaluated, the bases immediately before the donor and immediately following the acceptor are examined, and if a stop codon is formed, the predecessor is no longer considered eligible for selection in the corresponding phase.</p><p>As shown in Figure <xref ref-type="fig" rid="F5">5</xref>, when a signal has been eclipsed in all three phases it can be removed from its queue. In this way, as a signal falls further and further behind the current position in the sequence, the signal becomes more and more likely to be eclipsed in all three phases as randomly formed stop codons are encountered in the sequence, so that coding queues (e.g., those holding forward strand start codons and acceptors, or reverse strand donors and stop codons) tend not to grow without bound, but to be limited on average to some maximal load determined by the nucleotide composition statistics of the sequence. Because of this effect, the expected number of signals which must be considered during predecessor evaluation can be considered effectively constant in practice.</p><p>In the case of noncoding queues (e.g., those holding forward strand donors or stop codons, etc.), the assumption that noncoding features follow a geometric (i.e., exponentially decreasing) distribution allows us to limit these queues to a single element (per phase), because once a noncoding predecessor has been selected in a given phase, no other noncoding predecessor which has already been compared to the selected predecessor can ever become more attractive by virtue of its transition probability (since they are the same for signals of the same type, of which all the signals in a single queue are), its duration probability (since the geometric distribution ensures that their respective duration probabilities decrease at the same rate), nor its sequence probability (since any nucleotides encountered after seeing the two potential predecessors will affect their sequence scores identically).</p><p>Because the coding and noncoding queues are effectively limited to a constant load (as argued above), the expected processing time at each nucleotide is O(1) in practice and therefore the entire algorithm up to this point requires time O(<italic>L</italic>) for an input sequence of length <italic>L </italic>and a GHMM with a fixed number of states. It will be seen that the traceback procedure described below also requires time O(<italic>L</italic>), and so this is the time complexity of the PSA decoding algorithm for normal eukaryotic genomes (i.e., those not especially lacking in random stop codons).</p><p>Once the end of the sequence is reached, the optimal parse &#x003c6; can be reconstructed by tracing back through the trellis links. In order for this to be done, a set of virtual, <italic>anchor signals </italic>(one of each type) must be instantiated at either terminus of the sequence (each having signal score <italic>R</italic><sub><italic>S </italic></sub>= 0). Those at the left terminus will have been entered into the appropriate queues at the very start of the algorithm as prospective targets for the first trellis links (and having inductive scores <italic>R</italic><sub><italic>I </italic></sub>= 0), and those at the right terminus are the last signals to be evaluated and linked into the trellis. The highest scoring of these right terminal anchor signals is selected (in its highest-scoring phase) as the starting point for the traceback procedure. Traceback consists merely of following the trellis links backward while adjusting for phase changes across exons, as shown in Figure <xref ref-type="fig" rid="F6">6</xref>.</p><p>Modifications to Figure <xref ref-type="fig" rid="F6">6</xref> for features on the reverse-strand include changing the AG on line 8 to GT, changing the subtraction on line 9 to addition, and changing the 0 on line 7 to 2.</p><p>It should be clear from the foregoing that the space requirements of the PSA decoding algorithm are <italic>O</italic>(<italic>L</italic>|<italic>Q</italic>|) for sequence length <italic>L </italic>and variable-duration state set <italic>Q</italic>. If, for example, array elements are 8-byte double-precision floating point numbers, then the GHMM depicted in Figure <xref ref-type="fig" rid="F1">1</xref> would require 14 prefix sum arrays (4 exon states &#x000d7; 3 phases + 1 intergenic state + 1 intron state), resulting in a memory requirement of at least 112 bytes per nucleotide. Generalizing this GHMM to handle both DNA strands would increase this to 216 bytes per nucleotide, so that processing of a 1 Mb sequence would require at least 216 Mb of RAM just for the arrays. Adding states for 5' and 3' untranslated regions would increase this to 248 Mb of RAM for a 1 Mb sequence, or over 1 Gb of RAM for a 5 Mb sequence. For the purposes of comparative gene finding on multiple organisms with large genes, these requirements seem less than ideal, especially when one considers the possibility of adding yet other states.</p><p>The memory requirements can be reduced in several ways. First, Markov chains can be shared by similar states. For example, the intron and intergenic states can share a single Markov chain trained on pooled noncoding DNA, and all the exon states can use the same three-periodic Markov chain trained on pooled coding DNA. To our knowledge, the extent to which this optimization affects the accuracy of the resulting gene finder has not been systematically investigated, though it is commonly used in practice. Second, the models for exons can be modified so as to utilize likelihood ratios instead of probabilities. If the models for exons are re-parameterized to compute:</p><p><inline-graphic xlink:href="1471-2105-6-16-i5.gif"/></p><p>and the noncoding models are modified to compute:</p><p><inline-graphic xlink:href="1471-2105-6-16-i6.gif"/></p><p>then the latter can be seen to be unnecessary, since it will always evaluate to 1. Such a modification is valid and will have no effect on the mathematical structure of the optimization problem given in Equation 2 as long as the denominator is evaluated using a Markov chain or other multiplicative model, since the effect of the denominator on inductive scores will then be constant across all possible predecessors for any given signal. Using such ratios allows us to skip the evaluation of all noncoding states, so that the number of prefix sum arrays required for a double-stranded version of the GHMM in Figure <xref ref-type="fig" rid="F1">1</xref> would be only 6 (assuming the previous optimization is applied as well), corresponding to the three exon phases on two strands. Furthermore, to the extent that these likelihood ratios are expected to have a relatively limited numerical range, lower-precision floating point numbers can be used, or the ratios could instead be multiplied by an appropriate scaling factor and then stored as 2-byte integers [<xref ref-type="bibr" rid="B2">2</xref>]. This is a significant reduction, though asymptotically the complexity is still O(<italic>L</italic>|<italic>Q</italic>|). An additional consideration is that the log-likelihood strategy makes unavailable (or at least inseparable) the raw coding and noncoding scores, which might be desired later for some unforeseen application.</p><p>A third method of reducing the memory requirements is to eliminate the prefix sum arrays altogether, resulting in what we call the Dynamic Score Propagation (DSP) algorithm.</p></sec><sec><title>The DSP decoding algorithm</title><p>Informally, the DSP algorithm is similar to the PSA algorithm except that rather than storing all nucleotide scores for all content sensors in a set of prefix sum arrays, we instead store only the specific elements of those arrays that are needed for assessing prospective predecessors during the trellis formation. Associated with each signal is a "propagator" variable which represents the log probability of the highest-scoring partial parse up to and including this signal. As processing proceeds left-to-right along the sequence, these propagators are updated so as to extend these partial parses up to the current position. In this way, the inductive score of each signal is incrementally propagated up to each potential successor signal that is encountered during processing; when a signal is eclipsed in all phases by stop codons (i.e., removed from its respective queue), propagation of that signal's inductive score halts, since further updates would be useless beyond that point. Because no prefix sum arrays are allocated, and because the signal queues are effectively limited in size (as argued previously), the expected memory requirements of DSP will be seen to be O(<italic>L</italic>+|<italic>Q</italic>|), where the constant factor associated with the <italic>L </italic>term is small, reflecting only the number of signals per nucleotide emitted by the signal sensors, as well as the memory required to store the sequence itself.</p><p>Let us introduce some notation. We define a <italic>propagator </italic>&#x003c0; to be a 3-element array, indexed using the notation &#x003c0;[<italic>i</italic>] for 0&#x02264;<italic>i</italic>&#x02264;2; when dealing with multiple propagators, &#x003c0;<sub><italic>j</italic></sub>[<italic>i</italic>] will denote element <italic>i </italic>of the <italic>j</italic><sup>th </sup>propagator.</p><p>Each signal <italic>s</italic><sub><italic>i </italic></sub>will now have associated with it a propagator, denoted &#x003c0;<sub><italic>i</italic></sub>. For signals which can be members of multiple queues (such as start codons, which can be members of both the <italic>initial exon </italic>queue and the <italic>single exon </italic>queue), the signal will have one propagator per queue, but it will be clear from the context to which propagator we refer. Each queue will also have a propagator associated with it, though for the sake of reducing ambiguity we will refer to these as <italic>accumulators </italic>and represent them with the symbol &#x003b1;. The purpose of the accumulators is to reduce the number of updates to individual signal propagators; otherwise, every signal propagator in every queue would need to be updated at every position in the input sequence. The accumulator for a given queue will accumulate additions to be made to the propagators of the signals currently in the queue. The update of signal propagators from their queue's accumulator is delayed as long as possible, as described below. Accumulator scores are initialized to zero, as are the propagator scores for the left terminus anchor signals; the general case of propagator initialization will be described shortly.</p><p>Updating of a propagator &#x003c0; from an accumulator &#x003b1; is simple in the case of a noncoding queue:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub>&#x003c0;[&#x003c9;] &#x02190; &#x003c0;[&#x003c9;] + &#x003b1;[0]. &#x000a0;&#x000a0;&#x000a0; (13)</p><p>For coding queues, the update must take into account the location of the signal <italic>s </italic>associated with the propagator &#x003c0;, in order to synchronize the periodic association between phase and array index:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub>&#x003c0;[&#x003c9;] &#x02190; &#x003c0;[&#x003c9;] + &#x003b1;[(&#x003c9; - <italic>pos</italic>(<italic>s</italic>) - <italic>len</italic>(<italic>s</italic>))<bold>mod</bold>3], &#x000a0;&#x000a0;&#x000a0; (14)</p><p>or, on the reverse strand:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub>&#x003c0;[&#x003c9;] &#x02190; &#x003c0;[&#x003c9;] + &#x003b1;[(&#x003c9; + <italic>pos</italic>(<italic>s</italic>) + <italic>len</italic>(<italic>s</italic>))<bold>mod</bold>3]. &#x000a0;&#x000a0;&#x000a0; (15)</p><p>Given a content sensor <italic>M</italic>, a coding accumulator can be updated according to the rule:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub>&#x003b1;[&#x003c9;] &#x02190; &#x003b1;[&#x003c9;] + <bold>log </bold><italic>P</italic><sub><italic>M</italic>[(&#x003c9;+<italic>f</italic>)<bold>mod</bold>3]</sub>(<italic>x</italic><sub><italic>f</italic></sub>), &#x000a0;&#x000a0;&#x000a0; (16)</p><p>or, on the reverse strand:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub>&#x003b1;[&#x003c9;] &#x02190; &#x003b1;[&#x003c9;] + <bold>log </bold><italic>P</italic><sub><italic>W</italic>[(&#x003c9;-<italic>f</italic>)<bold>mod</bold>3]</sub>(<italic>x</italic><sub><italic>f</italic></sub>), &#x000a0;&#x000a0;&#x000a0; (17)</p><p>where <italic>f </italic>is the position of the current nucleotide <italic>x</italic><sub><italic>f</italic></sub>, <italic>P</italic><sub><italic>M</italic>[&#x003c9;]</sub>(<italic>x</italic><sub><italic>f</italic></sub>) is the probability assigned to <italic>x</italic><sub><italic>f </italic></sub>by the content sensor <italic>M </italic>in phase &#x003c9;, and <italic>W </italic>is the reverse-complementary model to <italic>M </italic>which computes the probability of its parameter on the opposite strand and taking contexts from the right rather than from the left. This update occurs once at each position along the input sequence. Use of <italic>f </italic>provides an absolute frame of reference when updating the accumulator. This is necessary because the accumulator for a queue has no intrinsic notion of phase: unlike an individual signal, a queue is not rooted at any particular location relative to the sequence.</p><p>For noncoding queues, only the 0<sup>th </sup>element of the accumulator must be updated:</p><p>&#x003b1;[0] &#x02190; &#x003b1;[0] + <bold>log </bold><italic>P</italic><sub><italic>M</italic></sub>(<italic>x</italic><sub><italic>f</italic></sub>). &#x000a0;&#x000a0;&#x000a0; (18)</p><p>All that remains is to specify the rule for selecting an optimal predecessor and using it to initialize a new signal's propagator. We first consider new signals which terminate a putative exon. Let <italic>s</italic><sub><italic>i </italic></sub>denote the predecessor under consideration and <italic>s</italic><sub><italic>j </italic></sub>the new signal. Denote by &#x00394; the length of the putative exon. Then on the forward strand, we can compare predecessors with respect to phase &#x003c9; via the scoring function <italic>R</italic><sub><italic>CI </italic></sub>+ <italic>R</italic><sub><italic>D </italic></sub>+ <italic>R</italic><sub><italic>T</italic></sub>, where <italic>R</italic><sub><italic>D </italic></sub>and <italic>R</italic><sub><italic>T </italic></sub>are the duration and transition scores described earlier and <italic>R</italic><sub><italic>CI </italic></sub>includes the content score and the inductive score from the previous signal:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub><italic>R</italic><sub><italic>CI</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003c9;) &#x02190; &#x003c0;<sub><italic>i</italic></sub>[(&#x003c9; - &#x00394;)<bold>mod</bold>3]. &#x000a0;&#x000a0;&#x000a0; (19)</p><p>On the reverse strand we have:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub><italic>R</italic><sub><italic>CI</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003c9;) &#x02190; &#x003c0;<sub><italic>i </italic></sub>[(&#x003c9; + &#x00394;)<bold>mod</bold>3]. &#x000a0;&#x000a0;&#x000a0; (20)</p><p>For introns it is still necessary to separate the three phase-specific scores to avoid greedy behavior, though the phase does not change across an intron, so no &#x00394; term is necessary:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub><italic>R</italic><sub><italic>CI</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003c9;) &#x02190; &#x003c0;<sub><italic>i</italic></sub>[&#x003c9;]. &#x000a0;&#x000a0;&#x000a0; (21)</p><p>When the preceding feature is intergenic we need only refer to phase zero of the preceding stop codon:</p><p><italic>R</italic><sub><italic>CI</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003c9;) &#x02190; &#x003c0;<sub><italic>i</italic></sub>[0], &#x000a0;&#x000a0;&#x000a0; (22)</p><p>or, on the reverse strand, phase 2 of the preceding start codon (since the leftmost base of the reverse-strand start codon will reside in phase 2).</p><p>Once an optimal predecessor with score <italic>R</italic><sub><italic>CI </italic></sub>+ <italic>R</italic><sub><italic>D </italic></sub>+ <italic>R</italic><sub><italic>T </italic></sub>is selected with respect to a given phase &#x003c9;, the appropriate element of the new signal's propagator can be initialized directly:</p><p>&#x003c0;<sub><italic>j</italic></sub>[&#x003c9;] &#x02190; <italic>R</italic><sub><italic>CI</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003c9;) + <italic>R</italic><sub><italic>D</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>) + <italic>R</italic><sub><italic>T</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>) + <italic>R</italic><sub><italic>S</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>), &#x000a0;&#x000a0;&#x000a0; (23)</p><p>where <italic>R</italic><sub><italic>S</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>) = <italic>P</italic>(<italic>context</italic>(<italic>s</italic><sub><italic>j</italic></sub>)|&#x003b8;<sub><italic>j</italic></sub>) is the score assigned to the context window of the new signal <italic>s</italic><sub><italic>j </italic></sub>by the appropriate signal sensor &#x003b8;<sub><italic>j</italic></sub>. An exception to Equation 23 occurs when &#x003c9; is not a valid phase for signal <italic>s</italic><sub><italic>j </italic></sub>(e.g., phase 1 for a start codon), in which case we instead set &#x003c0;<sub><italic>j</italic></sub>[&#x003c9;] to -&#x0221e;.</p><p>One final complication arises from the fact that the algorithm, as we have presented it, does not permit adjacent signals in a prospective parse to have overlapping signal sensor windows; to allow such would be to permit double-counting of nucleotide probabilities, thereby biasing the probabilistic scoring function. It is a simple matter to reformulate the algorithm so that signal sensors score only the two or three consensus nucleotides of the signals under consideration; this would allow adjacent signals in a prospective parse to be as close as possible without actually overlapping (i.e., a single exon consisting of the sequence ATGTAG would be permitted, even if the start codon and stop codon context windows overlapped). However, doing so might be expected to decrease gene finder accuracy, for two reasons: (1) statistical biases occurring at fixed positions relative to signals of a given type can in general be better exploited by a signal sensor specifically trained on such positions than by a content sensor trained on data pooled from many positions at variable distances from the signal, and (2) in the case of Markov chains and Interpolated Markov Models, probability estimates for nucleotides immediately following a signal can be inadvertently conditioned on the few trailing nucleotides of the preceding feature (assuming the chain has a sufficiently high order), even though the models are typically not trained accordingly. For these reasons, we prefer to use signal sensors which impose a moderate margin around their respective signals, both to detect any biologically relevant biases which might exist within those margins, and to ensure that content sensors condition their probabilities only on nucleotides within the same feature.</p><p>Given the foregoing, it is necessary to utilize a separate "holding queue" for signals which have recently been detected by their signal sensors but which have context windows still overlapping the current position in the DSP algorithm. The reason for this is that propagator updates via Equations 13&#x02013;15 must not be applied to signals having context windows overlapping any nucleotides already accounted for in the accumulator scores, since to do so would be to double-count probabilities. It is therefore necessary to observe the following discipline.</p><p>Associated with each signal queue <italic>G</italic><sub><italic>i </italic></sub>there must be a separate <italic>holding queue</italic>, <italic>H</italic><sub><italic>i</italic></sub>. When a signal is instantiated by a signal sensor it is added to the appropriate <italic>H</italic><sub><italic>i </italic></sub>rather than to <italic>G</italic><sub><italic>i</italic></sub>. As the algorithm advances along the sequence, at each new position we must examine the contents of each holding queue <italic>H</italic><sub><italic>i </italic></sub>to identify any signal having a context window which has now passed completely to the left of the current position. If one or more such signals are identified, then we first update the propagators of all the signals in the main queue <italic>G</italic><sub><italic>i </italic></sub>using Equations 13&#x02013;15, then zero-out the values of the accumulator &#x003b1;<sub><italic>i </italic></sub>for that queue, and then allow the recently passed signals to graduate from <italic>H</italic><sub><italic>i </italic></sub>to <italic>G</italic><sub><italic>i</italic></sub>. Observe that at this point all the signals in <italic>G</italic><sub><italic>i </italic></sub>have in their propagators scores which have effectively been propagated up to the same point in the sequence, and that point is immediately left of the current position; this invariant is necessary for the proper operation of the algorithm. All content sensors are then evaluated at the current position and their resulting single-nucleotide scores are used to update the accumulators for their respective queues. Finally, whenever it becomes necessary to evaluate the signals in some queue <italic>G</italic><sub><italic>i </italic></sub>as possible predecessors of a new signal, we must first update the propagators of all the elements of <italic>G</italic><sub><italic>i </italic></sub>as described above, so that the comparison will be based on fully propagated scores.</p></sec><sec><title>Equivalence of DSP and PSA</title><p>We now give a proof that DSP is mathematically equivalent to PSA, since it may not be entirely obvious from the foregoing description. We will consider only the forward strand cases; the proof for the reverse strand cases can be derived by a series of trivial substitutions in the proof below.</p><p>To begin, we show by induction that the signal propagator &#x003c0;<sub><italic>j</italic></sub>[&#x003c9;] for signal <italic>s</italic><sub><italic>j </italic></sub>is initialized to the PSA inductive score <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>,&#x003c9;). For the basis step, recall that the left terminus anchor signals were initialized to have zero scores in both PSA and DSP, regardless of whether a given signal began a coding or noncoding feature. In the case of coding features, substituting Equation 19 into Equation 23 yields:</p><p>&#x003c0;<sub><italic>j</italic></sub>[&#x003c9;] &#x02190; &#x003c0;<sub><italic>i</italic></sub>[(&#x003c9; - &#x00394;)<bold>mod</bold>3] + <italic>R</italic><sub><italic>D</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>) + <italic>R</italic><sub><italic>T</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>) + <italic>R</italic><sub><italic>S</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>). &#x000a0;&#x000a0;&#x000a0; (24)</p><p>According to Equation 10, this initialization will result in &#x003c0;<sub><italic>j</italic></sub>[&#x003c9;] = <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>,&#x003c9;) only if:</p><p>&#x003c0;<sub><italic>i</italic></sub>[(&#x003c9; - &#x00394;)<bold>mod</bold>3] = <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub><italic>,&#x003b3;</italic><sub><italic>i</italic></sub>) + <italic>R</italic><sub><italic>C</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>,&#x003c9;), &#x000a0;&#x000a0;&#x000a0; (25)</p><p>where &#x003b3;<sub><italic>i </italic></sub>= (&#x003c9; - &#x00394;)<bold>mod</bold>3 according to Equation 8. At the time that signal <italic>s</italic><sub><italic>j </italic></sub>is instantiated by its signal sensor, &#x003c0;<sub><italic>i </italic></sub>has been propagated up to <italic>e </italic>= <italic>wpos</italic>(<italic>s</italic><sub><italic>j</italic></sub>) - 1, the nucleotide just before the leftmost position of the context window for <italic>s</italic><sub><italic>j</italic></sub>. By the inductive hypothesis, &#x003c0;<sub><italic>i</italic></sub>[&#x003b3;<sub><italic>i</italic></sub>] was initialized to <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003b3;<sub><italic>i</italic></sub>). This initialization occurred at the time when the current DSP position was at the beginning of the predecessor's context window. Note, however, that &#x003c0;<sub><italic>i </italic></sub>effectively began receiving updates at position <italic>b </italic>= <italic>wpos</italic>(<italic>s</italic><sub><italic>i</italic></sub>) + <italic>wlen</italic>(<italic>s</italic><sub><italic>i</italic></sub>), the position immediately following the end of the signal's context window, at which point <italic>s</italic><sub><italic>i </italic></sub>graduated from its holding queue. Thus, &#x003c0;<sub><italic>i</italic></sub>[&#x003b3;<sub><italic>i</italic></sub>] will have accumulated content scores for positions <italic>b </italic>through <italic>e</italic>, inclusive. In order to establish Equation 25, we need to show that these accumulations sum to precisely <italic>R</italic><sub><italic>C</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>,&#x003c9;).</p><p>Substituting Equation 16 into Equation 14 we get the following formula describing propagator updates as if they came directly from content sensor <italic>M</italic>:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub>&#x003c0;[&#x003c9;] &#x02190; &#x003c0;[&#x003c9;] + <bold>log </bold><italic>P</italic><sub><italic>M</italic>[(&#x003c9;+<italic>&#x00394;</italic>)<bold>mod</bold>3]</sub>(<italic>x</italic><sub><italic>f</italic></sub>), &#x000a0;&#x000a0;&#x000a0; (26)</p><p>where &#x00394; = <italic>f</italic>-(<italic>pos</italic>(<italic>s</italic><sub><italic>i</italic></sub>) + <italic>len</italic>(<italic>s</italic><sub><italic>i</italic></sub>)) is the distance between the rightmost end of signal <italic>s</italic><sub><italic>i </italic></sub>and the current position <italic>f </italic>in the DSP algorithm. Let us introduce the notation:</p><p>F(<italic>i</italic>,<italic>j</italic>,&#x003c9;) = &#x02211;<sub><italic>k </italic>= <italic>i</italic>..<italic>j</italic></sub><bold>log </bold><italic>P</italic><sub><italic>M</italic>[(&#x003c9;+<italic>k</italic>)<bold>mod</bold>3]</sub>(<italic>x</italic><sub><italic>k</italic></sub>). &#x000a0;&#x000a0;&#x000a0; (27)</p><p>Using this notation, &#x003c0;<sub><italic>i</italic></sub>[&#x003b3;<sub><italic>i</italic></sub>] has since its initialization accumulated F(<italic>b</italic>,<italic>e</italic>,&#x003b3;<sub><italic>i </italic></sub>- <italic>pos</italic>(<italic>s</italic><sub><italic>i</italic></sub>) - <italic>len</italic>(<italic>s</italic><sub><italic>i</italic></sub>)); this can be verified by expanding this expression via Equation 27 and observing that the result equals a summation of the log term in Equation 26 over <italic>f </italic>= <italic>b </italic>to <italic>e</italic>. Looking at init_phased(), it should be obvious that the effect of lines 5 and 8 will be that:</p><p>&#x003b1;<sub><italic>i</italic>,&#x003b3; </sub>[<italic>h</italic>] = &#x02211;<sub><italic>k </italic>= 0..<italic>h</italic></sub><bold>log </bold><italic>P</italic><sub><italic>M </italic>[(<italic>k</italic>+&#x003b3;)<italic>mod</italic>3]</sub>(<italic>x</italic><sub><italic>k</italic></sub>) = F(0,h,&#x003b3;). &#x000a0;&#x000a0;&#x000a0; (28)</p><p>According to Equation 5, showing that &#x003c0;<sub><italic>i</italic></sub>[&#x003b3;<sub><italic>i</italic></sub>] has accumulated <italic>R</italic><sub><italic>C</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>,&#x003c9;) is therefore equivalent to:</p><p><italic>F</italic>(<italic>b</italic>,<italic>e</italic>,&#x003c8;) = <italic>F</italic>(0,<italic>wpos</italic>(<italic>s</italic><sub><italic>j</italic></sub>) - 1,&#x003b3;) - <italic>F</italic>(0,<italic>wpos</italic>(<italic>s</italic><sub><italic>i</italic></sub>) + <italic>wlen</italic>(<italic>s</italic><sub><italic>i</italic></sub>) - 1,&#x003b3;), &#x000a0;&#x000a0;&#x000a0; (29)</p><p>where &#x003c8; = &#x003b3;<sub><italic>i </italic></sub>- <italic>pos</italic>(<italic>s</italic><sub><italic>i</italic></sub>) - <italic>len</italic>(<italic>s</italic><sub><italic>i</italic></sub>) and &#x003b3; = &#x003c9; - <italic>pos</italic>(<italic>s</italic><sub><italic>j</italic></sub>). Equivalently:</p><p><italic>F</italic>(<italic>b</italic>,<italic>e</italic>,&#x003c8;) = <italic>F</italic>(0,<italic>e</italic>,&#x003b3;) - <italic>F</italic>(0,<italic>b </italic>- 1,&#x003b3;). &#x000a0;&#x000a0;&#x000a0; (30)</p><p>To see that &#x003c8; &#x02261; &#x003b3;(<bold>mod</bold>3), observe that <italic>pos</italic>(<italic>s</italic><sub><italic>j</italic></sub>) - (<italic>pos</italic>(<italic>s</italic><sub><italic>i</italic></sub>) + <italic>len</italic>(<italic>s</italic><sub><italic>i</italic></sub>)) = &#x00394;, the length of the putative exon (possibly shortened by three bases, in the case where <italic>s</italic><sub><italic>i </italic></sub>is a start codon), and further that &#x003b3;<sub><italic>i </italic></sub>- &#x003c9; &#x02261; -&#x00394;(<bold>mod</bold>3) according to Equation 8, so that &#x003c8; - &#x003b3; &#x02261; &#x00394;-&#x00394; &#x02261; 0(<bold>mod</bold>3). Thus, Equation 30 is equivalent to:</p><p><italic>F</italic>(<italic>b</italic>,<italic>e</italic>,&#x003b3;) = <italic>F</italic>(0,<italic>e</italic>,&#x003b3;) - <italic>F</italic>(0,<italic>b </italic>- 1,&#x003b3;), &#x000a0;&#x000a0;&#x000a0; (31)</p><p>which can be established as a tautology by simple algebra after expansion with Equation 27. This shows that the signal propagator for signal <italic>s</italic><sub><italic>j </italic></sub>is initialized to the PSA inductive score <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>j</italic></sub>,&#x003c9;), and thus establishes the inductive step of the proof in the case of coding features.</p><p>To see that the above arguments also hold for noncoding features, note that Equation 21 simplifies Equation 25 to:</p><p>&#x003c0;<sub><italic>i</italic></sub>[&#x003c9;] = <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003c9;) + <italic>R</italic><sub><italic>C</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>), &#x000a0;&#x000a0;&#x000a0; (32)</p><p>that Equations 13 and 18 combine to simplify Equation 26 to:</p><p>&#x02200;<sub>0&#x02264;&#x003c9;&#x02264;2 </sub>&#x003c0;[&#x003c9;] &#x02190; &#x003c0;[&#x003c9;] + <bold>log </bold><italic>P</italic><sub><italic>M</italic></sub>(<italic>x</italic><sub><italic>f</italic></sub>), &#x000a0;&#x000a0;&#x000a0; (33)</p><p>and that lines 4 and 6 of init_nonphased() cause:</p><p>&#x003b1;<sub><italic>i</italic></sub>[<italic>h</italic>] = &#x02211;<sub><italic>k </italic>= 0..<italic>h</italic></sub><bold>log </bold><italic>P</italic><sub><italic>M</italic></sub>(<italic>x</italic><sub><italic>k</italic></sub>) = F<sub><italic>NC</italic></sub>(0,<italic>h</italic>), &#x000a0;&#x000a0;&#x000a0; (34)</p><p>for <italic>F</italic><sub><italic>NC</italic></sub>(<italic>i</italic>,<italic>j</italic>) = &#x02211;<sub><italic>k </italic>= <italic>i</italic>..<italic>j</italic></sub><bold>log </bold><italic>P</italic><sub><italic>M</italic></sub>(<italic>x</italic><sub><italic>k</italic></sub>). We can thus reformulate Equation 29 as:</p><p><italic>F</italic><sub><italic>NC</italic></sub>(<italic>b</italic>,<italic>e</italic>) = <italic>F</italic><sub><italic>NC</italic></sub>(0,<italic>wpos</italic>(<italic>s</italic><sub>cur</sub>) - 1) - <italic>F</italic><sub><italic>NC</italic></sub>(0,<italic>wpos</italic>(<italic>s</italic><sub>pred</sub>) + <italic>wlen</italic>(<italic>s</italic><sub>pred</sub>) - 1), &#x000a0;&#x000a0;&#x000a0; (35)</p><p>or, equivalently:</p><p><italic>F</italic><sub><italic>NC</italic></sub>(<italic>b</italic>,<italic>e</italic>) = <italic>F</italic><sub><italic>NC</italic></sub>(0,<italic>e</italic>) - <italic>F</italic><sub><italic>NC</italic></sub>(0,<italic>b </italic>- 1), &#x000a0;&#x000a0;&#x000a0; (36)</p><p>which is again a tautology. In the interests of brevity, we leave it up to the reader to verify that the above arguments still apply when the noncoding features are intergenic, thereby invoking Equation 22 rather than Equation 21 in formulating Equation 31.</p><p>To see that the selection of optimal predecessors is also performed identically in the two algorithms, note that the PSA criterion given in Equation 7 is equivalent to the argmax(<italic>R</italic><sub><italic>CI </italic></sub>+ <italic>R</italic><sub><italic>D </italic></sub>+ <italic>R</italic><sub><italic>T</italic></sub>) criterion of DSP as long as <italic>R</italic><sub><italic>CI</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,&#x003c9;) = <italic>R</italic><sub><italic>C</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub>,<italic>s</italic><sub><italic>j</italic></sub>,&#x003c9;) + <italic>R</italic><sub><italic>I</italic></sub>(<italic>s</italic><sub><italic>i</italic></sub><italic>,&#x003b3;</italic><sub><italic>i</italic></sub>) at the time the optimal predecessor is selected, which we have in fact already shown by establishing Equation 25.</p><p>Thus, DSP and PSA build identical trellises; application of the same traceback() procedure should therefore produce identical gene predictions.</p></sec><sec><title>Fast decoding of Markov chains</title><p>Markov chains are typically implemented in GHMM-based gene finders using hash tables, due to the simplicity of such an implementation. Thus, for a given Markov chain <italic>M </italic>we may utilize a hash table which associates the probability <italic>P</italic><sub><italic>M</italic></sub>(<italic>x</italic><sub><italic>j</italic></sub>|<italic>x</italic><sub><italic>j</italic>-<italic>n</italic></sub>..<italic>x</italic><sub><italic>j</italic>-1</sub>) with the sequence <italic>x</italic><sub><italic>j</italic>-<italic>n</italic></sub>..<italic>x</italic><sub><italic>j</italic></sub>. Although hash tables provide a relatively efficient solution for this task, they are wasteful in the sense that as we evaluate the chain on successive nucleotides in a sequence, we repeatedly manipulate preceding nucleotides in forming successive substrings to be indexed into the hash table.</p><p>A much faster (and much more elegant) solution is to employ a Finite State Machine (FSM) in which states exist for all possible sequences of length <italic>n</italic>+1 or less, and where the state having label <italic>x</italic><sub><italic>j</italic>-<italic>n</italic></sub>..<italic>x</italic><sub><italic>j </italic></sub>emits the probability <italic>P</italic><sub><italic>M</italic></sub>(<italic>x</italic><sub><italic>j</italic></sub>|<italic>x</italic><sub><italic>j</italic>-<italic>n</italic></sub>..<italic>x</italic><sub><italic>j</italic>-1</sub>), for <italic>n</italic><sup>th</sup>-order Markov chain <italic>M</italic>. In this way, the transition probabilities of the Markov chain become the state emissions of the FSM. During a single left-to-right scan of a sequence, each base requires only a single two-dimensional array indexing operation to access the desired probability, and a single integer value store operation to remember the identity of the new state. When compared to the typical regime of arithmetic and bit-shift operations over an (<italic>n</italic>+1)-element string that would be required for a typical hash function, the difference can be significant.</p><p>Implementing this optimization is fairly straightforward, both for conventional Markov chains and for Interpolated Markov Models, whether homogeneous or three-periodic. Central to the method is a means of mapping between state labels and integer state identifiers for use in indexing into the transition table. The base-4 number system can be utilized for this purpose, assuming a nucleotide mapping such as &#x02207; = {A&#x02194;0, C&#x02194;1, G&#x02194;2, T&#x02194;3}. To account for lower-order states, define:</p><p><inline-graphic xlink:href="1471-2105-6-16-i7.gif"/></p><p>which gives the total number of strings of length less than <italic>L</italic>. Converting a string <italic>S </italic>= <italic>x</italic><sub>0</sub>..<italic>x</italic><sub><italic>L</italic>-1 </sub>to base-4 can be accomplished as follows:</p><p><inline-graphic xlink:href="1471-2105-6-16-i8.gif"/></p><p>Now a string <italic>S </italic>can be mapped to a state index using:</p><p><italic>state</italic>(<italic>S</italic>) = <italic>B</italic>(|<italic>S</italic>|) + &#x003bb;(<italic>S</italic>), &#x000a0;&#x000a0;&#x000a0; (39)</p><p>where |<italic>S</italic>| denotes the length of <italic>S</italic>.</p><p>Given this integer&#x02194;label mapping and an <italic>n</italic><sup>th</sup>-order Markov chain in hash table format, the FSM state emissions can be initialized by indexing state labels into the hash table to obtain the Markov chain transition probabilities. The transition table can be initialized fairly simply by noting that the successor of state <italic>x</italic><sub>0</sub>..<italic>x</italic><sub><italic>L</italic>-1 </sub>upon seeing symbol <italic>s </italic>is <italic>x</italic><sub>1</sub>..<italic>x</italic><sub><italic>L</italic>-1</sub><italic>s </italic>if <italic>L </italic>= <italic>n </italic>+ 1, or <italic>x</italic><sub>0</sub>..<italic>x</italic><sub><italic>L</italic>-1</sub><italic>s </italic>for <italic>L </italic>&#x0003c;<italic>n </italic>+ 1. A model for the reverse strand can be handled by applying this scheme in reverse, so that the state with label <italic>x</italic><sub><italic>j</italic>-<italic>n</italic></sub>..<italic>x</italic><sub><italic>j </italic></sub>emits the probability <italic>P</italic><sub><italic>M</italic></sub>(<italic>x</italic><sub><italic>j</italic>-<italic>n</italic></sub>|<italic>x</italic><sub><italic>j</italic>-<italic>n</italic>+1</sub>..<italic>x</italic><sub><italic>j</italic></sub>), and the lower-order states are reserved for the end of the sequence rather than the beginning.</p></sec></sec><sec><title>Results</title><p>Table <xref ref-type="table" rid="T1">1</xref> shows the memory and time requirements for two GHMM gene finders, one using the PSA algorithm and the other the DSP algorithm, on a 922 Kb sequence. Note that the DSP gene finder has 31 states, while the PSA gene finder explicitly evaluates only 6 states, so that they both give a ratio of 2.8 seconds per state on this sequence, while the ratio of memory per state is 14 Mb for the PSA gene finder and 0.95 Mb for the DSP gene finder. Thus, the DSP and PSA algorithms appear to consume the same amount of time per state, while DSP requires only a fraction of the memory (per state) as PSA.</p><p>Table <xref ref-type="table" rid="T2">2</xref> shows the results of applying the FSM optimization to a DSP gene finder to accelerate its content sensors. As can be seen from the table, the FSM approach reduces execution time by more than half (as compared to a hash table implementation), while also reducing total RAM usage. The DSP/FSM configuration reported here utilized both conventional Markov chains as well as Interpolated Markov Models, both represented using FSMs. Note that the hashing software used for comparison was a very efficient implementation which used native C character arrays; in particular, we did <italic>not </italic>use the C++ Standard Template Library (STL) implementations of <italic>string </italic>and <italic>hash</italic>, due to efficiency concerns regarding the re-copying of string arguments to the hash function. Our custom string hashing implementation was found to be much faster than the STL implementation (data not shown). Accordingly, one can expect an FSM implementation to show even greater gains as compared to an STL-based hashing implementation.</p><p>We utilized our DSP-based gene finder TIGRscan [<xref ref-type="bibr" rid="B5">5</xref>] in the construction of our syntenic gene finder TWAIN, a Generalized Pair HMM which performs gene prediction in two genomes simultaneously. TWAIN operates by invoking a modified version of TIGRscan to build a directed acyclic graph of all high-scoring parses of each of the two input sequences. Early experiments indicated that these parse graphs could be quite large in practice and may therefore require a significant portion of available RAM for their storage. In addition, the dynamic programming matrix used by TWAIN promised to be large as well. It was in anticipation of this problem that we were prompted to develop TIGRscan using the DSP architecture, to minimize the memory requirements of the underlying GHMM, thereby freeing the remaining available memory for use by the rest of the machinery within TWAIN.</p><p>As a result of these and other optimizations (such as our use of a sparse matrix representation for TWAIN's dynamic programming algorithm) we were able to apply TWAIN's gene prediction component to a pair of fungal genomes (<italic>Aspergillus fumigatus </italic>and <italic>A. nidulans</italic>) while consuming under 50 Mb of RAM, whereas an earlier prototype of this system applied to the same input data routinely exhausted all available memory on a computer with 1 Gb of RAM. We are hopeful that through the use of optimizations such as those described here we will be able to apply TWAIN to other pairs of genomes with longer genes, and possibly extend the program to handle more than two species simultaneously.</p></sec><sec><title>Conclusions</title><p>In describing a number of optimizations for GHMM-based gene finders and making available two complete open-source software systems embodying these methods, it is our hope that others will be more enabled to explore promising extensions to the GHMM framework, thereby improving the state-of-the-art in gene prediction techniques.</p></sec><sec><title>Availability and requirements</title><p>* <bold>Project name: </bold>TIGRscan, GlimmerHMM</p><p>* <bold>Project home page: </bold><ext-link ext-link-type="uri" xlink:href="http://www.tigr.org/software/pirate"/></p><p>* <bold>Operating system(s): </bold>Linux/UNIX</p><p>* <bold>Programming language: </bold>C/C++</p><p>* <bold>Other requirements: </bold>compiled using gcc 3.3.3</p><p>* <bold>License: </bold>Artistic License, see <ext-link ext-link-type="uri" xlink:href="http://www.opensource.org"/></p><p>* <bold>Any restrictions to use by non-academics: </bold>terms of Artistic License</p></sec><sec><title>Authors' contributions</title><p>The DSP algorithm was devised by WHM, who also performed the computational experiments and wrote the manuscript. The PSA gene finder GlimmerHMM was implemented by MP. MP, ALD, and SLS provided detailed insights into the PSA architecture and provided valuable comments on the manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>This work was supported in part by NIH grants R01-LM06845 and R01-LM007938.</p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kulp</surname><given-names>D</given-names></name><name><surname>Haussler</surname><given-names>D</given-names></name><name><surname>Reese</surname><given-names>MG</given-names></name><name><surname>Eeckman</surname><given-names>FH</given-names></name></person-group><article-title>A generalized hidden Markov model for the recognition of human genes in DNA</article-title><source>Proc Int Con Intell Syst Mol Biol</source><year>1996</year><volume>4</volume><fpage>134</fpage><lpage>142</lpage></citation></ref><ref id="B2"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Burge</surname><given-names>C</given-names></name></person-group><article-title>Identification of Genes in Human Genomic DNA</article-title><source>PhD Thesis</source><year>1997</year><publisher-name>Department of Mathematics, Stanford University</publisher-name></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cawley</surname><given-names>SE</given-names></name><name><surname>Wirth</surname><given-names>AI</given-names></name><name><surname>Speed</surname><given-names>TP</given-names></name></person-group><article-title>Phat &#x02013; a gene finding program for <italic>Plasmodium falciparum</italic></article-title><source>Mol Biochem Parasitol</source><year>2001</year><volume>118</volume><fpage>167</fpage><lpage>174</lpage><pub-id pub-id-type="pmid">11738707</pub-id><pub-id pub-id-type="doi">10.1016/S0166-6851(01)00363-2</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Stanke</surname><given-names>M</given-names></name><name><surname>Waack</surname><given-names>S</given-names></name></person-group><article-title>Gene prediction with a hidden Markov model and a new intron submodel</article-title><source>Bioinformatics</source><year>2003</year><volume>19</volume><fpage>II215</fpage><lpage>II225</lpage><pub-id pub-id-type="pmid">14534192</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btg1080</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Majoros</surname><given-names>WM</given-names></name><name><surname>Pertea</surname><given-names>M</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>TIGRscan and GlimmerHMM: two open-source <italic>ab initio </italic>eukaryotic gene finders</article-title><source>Bioinformatics</source><year>2004</year><volume>20</volume><fpage>2878</fpage><lpage>2879</lpage><pub-id pub-id-type="pmid">15145805</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/bth315</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Korf</surname><given-names>I</given-names></name></person-group><article-title>Gene finding in novel genomes</article-title><source>BMC Bioinf</source><year>2004</year><volume>5</volume><fpage>59</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-5-59</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pachter</surname><given-names>L</given-names></name><name><surname>Alexandersson</surname><given-names>M</given-names></name><name><surname>Cawley</surname><given-names>S</given-names></name></person-group><article-title>Applications of generalized pair hidden Markov models to alignment and gene finding problems</article-title><source>J Comput Biol</source><year>2002</year><volume>9</volume><fpage>389</fpage><lpage>399</lpage><pub-id pub-id-type="pmid">12015888</pub-id><pub-id pub-id-type="doi">10.1089/10665270252935520</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Alexandersson</surname><given-names>M</given-names></name><name><surname>Cawley</surname><given-names>S</given-names></name><name><surname>Pachter</surname><given-names>L</given-names></name></person-group><article-title>SLAM: Cross-species gene finding and alignment with a generalized pair hidden Markov model</article-title><source>Genome Res</source><year>2003</year><volume>13</volume><fpage>496</fpage><lpage>502</lpage><pub-id pub-id-type="pmid">12618381</pub-id><pub-id pub-id-type="doi">10.1101/gr.424203</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rabiner</surname><given-names>LR</given-names></name><name><surname>Juang</surname><given-names>B-H</given-names></name></person-group><article-title>An introduction to hidden Markov models</article-title><source>IEEE Transactions on Acoustics Speech, Signal Processing</source><year>1986</year><volume>3</volume><fpage>4</fpage><lpage>16</lpage></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rabiner</surname><given-names>LR</given-names></name></person-group><article-title>A tutorial on hidden Markov models and selected applications in speech recognition</article-title><source>Proceedings of the IEEE</source><year>1989</year><volume>77</volume><fpage>257</fpage><lpage>286</lpage><pub-id pub-id-type="doi">10.1109/5.18626</pub-id></citation></ref><ref id="B11"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Salzberg</surname><given-names>SL</given-names></name><name><surname>Searls</surname><given-names>DB</given-names></name><name><surname>Kasif</surname><given-names>S</given-names></name></person-group><source>Computational Methods in Molecular Biology</source><year>1998</year><publisher-name>Amsterdam: Elsevier</publisher-name></citation></ref><ref id="B12"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Durbin</surname><given-names>R</given-names></name><name><surname>Eddy</surname><given-names>S</given-names></name><name><surname>Krogh</surname><given-names>A</given-names></name><name><surname>Mitchison</surname><given-names>G</given-names></name></person-group><source>Biological Sequence Analysis</source><year>1998</year><publisher-name>Cambridge University Press</publisher-name></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Burge</surname><given-names>C</given-names></name><name><surname>Karlin</surname><given-names>S</given-names></name></person-group><article-title>Prediction of complete gene structures in human genomic DNA</article-title><source>J Mol Biol</source><year>1997</year><volume>268</volume><fpage>78</fpage><lpage>94</lpage><pub-id pub-id-type="pmid">9149143</pub-id><pub-id pub-id-type="doi">10.1006/jmbi.1997.0951</pub-id></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Salzberg</surname><given-names>SL</given-names></name><name><surname>Pertea</surname><given-names>M</given-names></name><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Gardner</surname><given-names>MJ</given-names></name><name><surname>Tettelin</surname><given-names>H</given-names></name></person-group><article-title>Interpolated Markov models for eukaryotic gene finding</article-title><source>Genomics</source><year>1999</year><volume>59</volume><fpage>24</fpage><lpage>31</lpage><pub-id pub-id-type="pmid">10395796</pub-id><pub-id pub-id-type="doi">10.1006/geno.1999.5854</pub-id></citation></ref><ref id="B15"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Majoros</surname><given-names>WM</given-names></name><name><surname>Pertea</surname><given-names>M</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Efficient implementation of a centralized Pair. Hidden Markov Model for comparative gene finding</article-title><source>Bioinformatics</source><year>2005</year><comment></comment></citation></ref></ref-list><sec sec-type="display-objects"><title>Figures and Tables</title><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>An example GHMM topology. </bold>Diamonds represent signal states (for fixed-length features) and circles represent content states (for variable-length features). Allowable transitions are shown with arrows. ATG = start codon, TAG = stop codon, GT = donor splice site, AG = acceptor splice site, N = intergenic region, I = intron, E<sub>init </sub>= initial exon, E<sub>int </sub>= internal exon, E<sub>fin </sub>= final exon, E<sub>sng </sub>= single exon gene. The denoted machine operates by transitioning stochastically from state to state, emitting a gene feature of a particular type upon entering a given state.</p></caption><graphic xlink:href="1471-2105-6-16-1"/></fig><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Non-overlapping of content and signal sensors. </bold>Fixed-length features such as start codons and donor sites are detected by signal sensors, which are used to score an entire context window surrounding the signal. To avoid double-counting, content sensors score only the nucleotides strictly between two signal sensors. In this example, the CTA at the end of the start codon sensor window and the CGA at the beginning of the donor site sensor window are not scored by the exon content sensor, even though they are part of the putative exon, since those bases are already scored by the signal sensors.</p></caption><graphic xlink:href="1471-2105-6-16-2"/></fig><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>The init_nonphased() algorithm. </bold>Initialization of a noncoding array &#x003b1;, given a sequence <italic>S </italic>= <italic>x</italic><sub>0</sub>..<italic>x</italic><sub><italic>L</italic>-1 </sub>and <italic>n</italic><sup>th</sup>-order Markov chain <italic>M</italic>. Note that all parameters are assumed passed by reference. The procedure initializes each array element to the log probability of the nucleotide at the corresponding position in the sequence, conditional on some number of preceding bases.</p></caption><graphic xlink:href="1471-2105-6-16-3"/></fig><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>The init_phased() algorithm. </bold>Initialization of a single exon array &#x003c3;, given a sequence <italic>S </italic>= <italic>x</italic><sub>0</sub>..<italic>x</italic><sub><italic>L</italic>-1</sub>, a set of three Markov chains <italic>P</italic><sub>{0,1,2}</sub>, and <italic>initial phase </italic>(i.e., phase of the first array element) &#x003c9;. All parameters are assumed to be passed by reference. This procedure is similar to init_nonphased(), except that the conditional probabilities are computed in a phase-specific manner by the appropriate member of the three-periodic Markov chain.</p></caption><graphic xlink:href="1471-2105-6-16-4"/></fig><fig position="float" id="F5"><label>Figure 5</label><caption><p><bold>The eclipse() algorithm. </bold>Eclipsing signals in queue <italic>G </italic>when a stop codon has been encountered at position <italic>p</italic>. All parameters are assumed to be passed by reference. pos(s) is the position of the first base of the signal's consensus sequence (e.g., the A in ATG). len(s) is the length of the signal's consensus sequence (e.g., 3 for ATG). The procedure operates by computing the phase &#x003c9; in which each signal is eclipsed by the stop codon, and then identifies those signals which are now eclipsed in all three phases. Any signal eclipsed in all three phases is then dropped from the queue, since any exon starting at that signal and extending up to the current position in the sequence would have an in-frame stop codon.</p></caption><graphic xlink:href="1471-2105-6-16-5"/></fig><fig position="float" id="F6"><label>Figure 6</label><caption><p><bold>The traceback() algorithm. </bold>Reconstruction of the optimal parse by tracing back through trellis links. Parameters are the selected right-terminus signal s and its chosen phase &#x003c9;. Returns a stack of signals constituting the optimal parse, with the top signal at the beginning of the parse and the bottom signal at the end. exon_length(p, s) denotes the number of coding nucleotides between p and s. The procedure operates by iteratively following the highest-scoring predecessor link from the current signal, adjusting the current phase as necessary when a trellis link corresponding to a coding feature is traversed.</p></caption><graphic xlink:href="1471-2105-6-16-6"/></fig><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Space and time requirements for two gene finders Two gene finders, the 31-state DSP gene finder TIGRscan, and the 6-state PSA gene finder GlimmerHMM, were run on a 922 Kb sequence. The DSP gene finder used raw probabilities and the PSA gene finder used log-likelihood ratios. The DSP implementation required less memory, both in total and per state, than the PSA implementation. Although the PSA implementation required less total time, the DSP implementation required the same amount of time per state, so that for a given gene finder with a fixed number of states, DSP decoding can be expected to be fully as fast as PSA decoding.</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="left"><bold>RAM (Mb)</bold></td><td align="left"><bold>RAM/state (Mb)</bold></td><td align="left"><bold>Time, min:sec</bold></td><td align="left"><bold>seconds/state</bold></td></tr></thead><tbody><tr><td align="left"><bold>31-state DSP</bold></td><td align="left">29</td><td align="left">0.95</td><td align="left">1:28</td><td align="left">2.8</td></tr><tr><td align="left"><bold>6-state PSA</bold></td><td align="left">84</td><td align="left">14</td><td align="left">0:17</td><td align="left">2.8</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Efficiency of Markov chain implementations Execution time for a 31-state GHMM gene finder utilizing hash tables or FSMs for its content sensors, applied to a 1.8 Mb sequence. The FSM implementation was over twice as fast as the hash table implementation, and required significantly less memory.</p></caption><table frame="hsides" rules="groups"><thead><tr><td></td><td align="left"><bold>time (min:sec)</bold></td><td align="left"><bold>total RAM</bold></td></tr></thead><tbody><tr><td align="left"><bold>DSP/Hash</bold></td><td align="left">1:15</td><td align="left">53 Mb</td></tr><tr><td align="left"><bold>DSP/FSM</bold></td><td align="left">0:34</td><td align="left">44 Mb</td></tr></tbody></table></table-wrap></sec></back></article>



