<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">15571634</article-id><article-id pub-id-type="pmc">PMC539352</article-id><article-id pub-id-type="publisher-id">1471-2105-5-186</article-id><article-id pub-id-type="doi">10.1186/1471-2105-5-186</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group></article-categories><title-group><article-title>Constraint Logic Programming approach to protein structure prediction</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Dal Pal&#x000f9;</surname><given-names>Alessandro</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>dalpalu@dimi.uniud.it</email></contrib><contrib id="A2" corresp="yes" contrib-type="author"><name><surname>Dovier</surname><given-names>Agostino</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>dovier@dimi.uniud.it</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Fogolari</surname><given-names>Federico</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>ffogolari@mail.dstb.uniud.it</email></contrib></contrib-group><aff id="I1"><label>1</label>Dipartimento di Matematica e Informatica, Universit&#x000e0; di Udine. Via delle Scienze 206, 33100 Udine, Italy</aff><aff id="I2"><label>2</label>Dipartimento di Scienze e Tecnologie Biomediche, Universit&#x000e0; di Udine, P.le Kolbe 4, 33100 Udine, Italy</aff><pub-date pub-type="collection"><year>2004</year></pub-date><pub-date pub-type="epub"><day>30</day><month>11</month><year>2004</year></pub-date><volume>5</volume><fpage>186</fpage><lpage>186</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/5/186"/><history><date date-type="received"><day>9</day><month>7</month><year>2004</year></date><date date-type="accepted"><day>30</day><month>11</month><year>2004</year></date></history><copyright-statement>Copyright &#x000a9; 2004 Dal Pal&#x000f9; et al; licensee BioMed Central Ltd.</copyright-statement><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p></license><abstract><sec><title>Background</title><p>The protein structure prediction problem is one of the most challenging problems in biological sciences. Many approaches have been proposed using database information and/or simplified protein models. The protein structure prediction problem can be cast in the form of an optimization problem. Notwithstanding its importance, the problem has very seldom been tackled by Constraint Logic Programming, a declarative programming paradigm suitable for solving combinatorial optimization problems.</p></sec><sec><title>Results</title><p>Constraint Logic Programming techniques have been applied to the protein structure prediction problem on the face-centered cube lattice model. Molecular dynamics techniques, endowed with the notion of constraint, have been also exploited. Even using a very simplified model, Constraint Logic Programming on the face-centered cube lattice model allowed us to obtain acceptable results for a few small proteins. As a test implementation their (known) secondary structure and the presence of disulfide bridges are used as constraints. Simplified structures obtained in this way have been converted to all atom models with plausible structure. Results have been compared with a similar approach using a well-established technique as molecular dynamics.</p></sec><sec><title>Conclusions</title><p>The results obtained on small proteins show that Constraint Logic Programming techniques can be employed for studying protein simplified models, which can be converted into realistic all atom models. The advantage of Constraint Logic Programming over other, much more explored, methodologies, resides in the rapid software prototyping, in the easy way of encoding heuristics, and in exploiting all the advances made in this research area, e.g. in constraint propagation and its use for pruning the huge search space.</p></sec></abstract></article-meta></front><body><sec><title>Background</title><p>Notwithstanding the continuous improvement in predictive methods, witnessed every two years by the world wide CASP experiment [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>], predicting the structure of a protein, given its sequence, is still in general beyond our capabilities. Brute force approaches, like exhaustive conformational searches or molecular dynamics simulations of the folding process, are precluded by the computing power available at present. Alternative, faster methods have been developed along two main lines:</p><p>1. assemblying the structure of a protein using structural fragments of similar sequences, available in the protein structure repository (the Protein Databank [<xref ref-type="bibr" rid="B3">3</xref>]), and later screening the feasibility of the resulting structures, using energetic criteria;</p><p>2. representing the protein chain by a highly simplified model which is, hopefully, treatable.</p><p>This second class of approaches is appealing in many respects [<xref ref-type="bibr" rid="B4">4</xref>]: first, the linkage between kinetics and thermodynamics of protein folding process and the basic intramolecular interactions is more easily addressable, because of the lesser number of variables. Second, the use of a simplified model agrees with the idea that details of atomic interactions between aminoacids are less important than the overall character of these interactions, because protein structure is flexible and can accommodate changes in the volume and shape of aminoacids much better than changes in their character (e.g. polar vs. hydrophobic [<xref ref-type="bibr" rid="B5">5</xref>]). Besides aiming at catching essential features of the protein folding process, simplified models have important computational advantages: generating and evaluating the energy of a conformation is efficiently done due to the reduced number of variables. A less evident benefit is that sampling (e.g. by molecular dynamics simulation or Monte Carlo methods) may be much more efficient due to the smoothness of energy surface due, once again, to the reduced number of degrees of freedom. Many lattice models have been used for simplified representation of proteins, up to date. Their capability of reproducing the secondary structure of proteins, as well as their relative arrangement has been reviewed by Godzik et al. [<xref ref-type="bibr" rid="B6">6</xref>]. A reasonable tradeoff between accuracy and the need to keep limited the number of base vectors is achieved by the face centered cubic (<inline-graphic xlink:href="1471-2105-5-186-i1.gif"/>) lattice studied by Toma and Toma [<xref ref-type="bibr" rid="B7">7</xref>]. In particular both <italic>&#x003b1;</italic>-helices and <italic>&#x003b2;</italic>-strands are modelled with a very low RMSD from standard regular structures. Lattice models have been used mainly for understanding general properties of proteins, rather than for real predictive tasks, although their use, especially in hierarchical protocols has been proposed and realized. In particular, the (210) lattice has been used successfully by Skolnick and Kolinski in prediction of a small beta protein [<xref ref-type="bibr" rid="B8">8</xref>] and many other useful applications have been reported since these earlier works (see e.g. for recent successful applications [<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B10">10</xref>] and also the two recent reviews [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B11">11</xref>]). A deep analysis of realistic lattice models of proteins proposed so far is definitely out of the scope of the present work, but there are few aspects of lattice models of proteins which need to be mentioned. The successful application of a lattice model depends obviously on the efficiency in generating conformations and searching for local minima. This aspect is dealt in the present work using Constraint Logic Programming, and taking advantage of all theoretical and implementative developments that have been realized in this context. The approach (and related languages) has been very seldom applied in the context of protein modeling and it has not been used for realistic protein structural predictions, to the best of our knowledge. A different, but equally important, aspect concerns the reliability of the model itself and of the forcefield used to evaluate conformational free energy. This aspect will not be dealt with by this work. An appropriate forcefield must take into account both local propensities to adopt a particular secondary structure (which ultimately depend on aminoacids' covalent structure and bulkiness) and their tendency to be in contact (which ultimately depends on their physico-chemical character). Contact potentials have been derived by many groups (see e.g. [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>]) based on the observed versus expected contacts stored in the database. A similar approach could be followed in order to derive a torsional potential in order to describe local conformational propensities. However, it is not obvious how these potentials should be derived for lattice models and how the two potentials are to be considered together. These problems are not investigated here. Rather we consider contact potentials previously derived by our group from statistical analysis of the database [<xref ref-type="bibr" rid="B13">13</xref>], which are expected not to be accurate for a lattice model, but nevertheless should be able to reproduce essential features of aminoacid interactions. The local propensity to adopt a particular secondary structure can be computed by predictive methods [<xref ref-type="bibr" rid="B14">14</xref>]. However, for the small peptides analyzed in this paper, the correct secondary structure is selected from the deposited structures for testing purposes.</p><p><italic>Constraint Logic Programming </italic>(briefly, <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/>) [<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B16">16</xref>] is a declarative programming paradigm particularly well-suited for encoding combinatorial minimization problems. It is the natural merger of the two declarative paradigms known as <italic>Constraint Solving </italic>and <italic>Logic Programming</italic>.</p><p>One of the peculiar features of <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> is the independence of the problem modeling and of the search's strategy. Problem modeling is based on traditional declarative programs in which one can use the built-in notion of <italic>constraint</italic>. Constraints are first-order formulas concerning variables that can assume values in some <italic>domains</italic>. The scheme is general. Various possible constraints and domains can be used. However, for combinatorial problems it is common to use <italic>finite domain constraints</italic>, namely arithmetic constraints between arithmetic expressions, where variables range over finite subsets of &#x02115;. Constraint Logic Programming over Finite Domains is known as <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/>(<inline-graphic xlink:href="1471-2105-5-186-i3.gif"/>). We briefly introduce this programming paradigm with a simple example. Let us consider three variables <italic>X</italic>, <italic>Y</italic>, <italic>Z </italic>that denote the number of possible items of some kind.</p><p>domain([<italic>X</italic>, <italic>Y</italic>, <italic>Z</italic>], 1, 10)</p><p>is a constraint that states that the three variables <italic>X</italic>, <italic>Y</italic>, <italic>Z </italic>have (finite) domain {1, 2, ..., 10}. Suppose we wish to state that the <italic>weight </italic>of each item of <italic>X </italic>is 3, of <italic>Y </italic>is 4, and of <italic>Z </italic>is 5 and the total weight of selected items must be less than or equal to 40. Moreover, we wish to state that the number of items of <italic>X </italic>plus those of <italic>Y </italic>must be less than those of <italic>Z</italic>. This can be simply stated as:</p><p>3 * <italic>X </italic>+ 4 * <italic>Y </italic>+ 5 * <italic>Z </italic>&#x02264; 40, <italic>X </italic>+ <italic>Y </italic>&#x0003c;<italic>Z</italic></p><p>We have modeled a sort of <italic>knapsack </italic>problem using <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/>(<inline-graphic xlink:href="1471-2105-5-186-i3.gif"/>). In general, in the modeling stage we can use constraints as well as declarative programs involving them.</p><p>Solution's search is performed by a <italic>constraint solver </italic>that is available in the language. The constraint solver uses constraints for sensibly pruning the search tree. One of the main capabilities is called <italic>constraint propagation</italic>. Constraint propagation reduces the domains of the variables eliminating those values that cannot lead to constraint solutions. For instance, in the considered example, constraint propagation reduces the domains of the variables <italic>X</italic>, <italic>Y</italic>, and <italic>Z </italic>to {1, ..., 4}, {1, ..., 4}, and {3, ..., 6}, respectively. For finding a possible solution, a further built-in capability &#x02013; the labeling predicate &#x02013; can be used. We can look for a generic solution as well as for a solution minimizing some function. In the example above, we could ask for minimizing the function -2<italic>X</italic><sup>2 </sup>+ <italic>Y </italic>+ 4<italic>Z</italic>. This can be done by adding a constraint of the form:</p><p><italic>F </italic>= -2 * <italic>X </italic>* <italic>X </italic>+ <italic>Y </italic>+ 4 * <italic>Z</italic>, labeling([minimize (<italic>F</italic>)], [<italic>X</italic>, <italic>Y</italic>, <italic>Z</italic>]).</p><p>The constraint solver then exploits the solution's search using constraint propagation and branch-and-bound techniques returning the answer:</p><p><italic>F </italic>= 3, <italic>X </italic>= 3, <italic>Y </italic>= 1, <italic>Z </italic>= 5</p><p>The library clpfd of SlCStus Prolog [<xref ref-type="bibr" rid="B17">17</xref>] allows to effectively program in this framework. Let us observe that it is not required that <italic>F </italic>be a linear function.</p><p>The above described approach to optimization combinatorial problems is the so-called <italic>Constrain &#x00026; Generate </italic>technique introduced as opposed to the <italic>Generate &#x00026; Test </italic>technique of the classical Logic Programming approach (see, e.g. [<xref ref-type="bibr" rid="B18">18</xref>]). In the latter approach, a first phase generates non-deterministically a possible solution, and then the deterministic test-phase checks whether the solution is acceptable or not. If the search space is exponential, this technique is not applicable. In the former approach, a first deterministic phase introduces a number of constraints, then a non-deterministic phase starts the generation of the solutions' space. The constraints introduced allow to sensibly prune the solutions' space in order to make the procedure effective. Moreover, in this phase one can take advantage from language built-in strategies (such as constraint propagation, branch and bound) and it is possible to further drive the solution search by means of problem-dependent heuristics.</p><p>We have followed the Constrain &#x00026; Generate programming style for encoding the protein structure prediction problem. As a matter of fact, the main predicate of our solution is of the form reported in Figure <xref ref-type="fig" rid="F1">1</xref>.</p><p>In the definition of the predicate constrain the protein structure prediction problem is modeled using constraints. In particular, the energy function is encoded in the Energy parameter, The predicate solution_search is aimed at looking for the solution minimizing the Energy parameter. The other predicates are auxiliary predicates. initialization resets some parameters, protein recovers the relevant input (see also <bold>Methods </bold>Section), writetime and print_results are output predicates. The constraint predicate is defined using several predicates each of them modeling one of the properties of the problem. For instance, the predicate next_constraints sets the distance between consecutive aminoacids (see Figure <xref ref-type="fig" rid="F2">2</xref>).</p><p>Briefly, next_constraints recursively calls the predicate next for each pair of consecutive aminoacids. Assume that &#x0003c;<italic>X</italic>1, <italic>Y</italic>1, <italic>Z</italic>1&#x0003e; and &#x0003c;<italic>X</italic>2, <italic>Y</italic>2, <italic>Z</italic>2&#x0003e; are the variables that will store the positions of a consecutive pair of aminoacids, then the predicate next states that |<italic>X</italic>1 - <italic>X</italic>2| + |<italic>Y</italic>1 - <italic>Y</italic>2| + |<italic>Z</italic>1- <italic>Z</italic>2| = 2 and that |<italic>X</italic>1 - <italic>X</italic>2| &#x02208; {0, 1}, |<italic>Y</italic>1 - <italic>Y</italic>2| &#x02208; {0, 1}, |<italic>Z</italic>1 - <italic>Z</italic>2| &#x02208; {0, 1}. This is exactly the notion of adjacency in the face-centered cubic lattice of size 2 that we have used (see also the <bold>Methods </bold>Section).</p></sec><sec><title>Results and discussion</title><sec><title>Constrained optimization problem in <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/>(<inline-graphic xlink:href="1471-2105-5-186-i3.gif"/>)</title><p>In Table <xref ref-type="table" rid="T1">1</xref> we report the results of the experiments with the <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/>(<inline-graphic xlink:href="1471-2105-5-186-i3.gif"/>) code described in the <bold>Methods </bold>Section. All tests are done using SICStus PROLOG 3.11.1 [<xref ref-type="bibr" rid="B17">17</xref>] and a PC P4, 3.06 GHz. The structures of the protein model systems analyzed are known and stored in the PDB [<xref ref-type="bibr" rid="B3">3</xref>]. In the protein model systems 1LE3, 1PG1, and 1ZDD terminal protecting groups have been neglected.</p><p>From left to right, the meaning of each column is as follows: the protein PDB identification code, the number <italic>N </italic>of aminoacids, the execution time, the energy of the best model found and its RMSD from the native structure for all the residues and for the core residues only. When there is not explicitly written "limit" it means that the program successfully terminated in the time reported; otherwise the program terminated due to time limit. We wish to observe that the results with time limit 10 h/24 h are typically computed in few hours. The rest of the time is used to further explore the solutions' space.</p><p>When a CF = <italic>&#x003b7; </italic>is reported a further constraint on the compactness ratio <italic>&#x003b7; </italic>is added before the search. CF = <italic>&#x003b7; </italic>bounds the linear distances |<italic>X</italic><sub><italic>i </italic></sub>- <italic>X</italic><sub><italic>j</italic></sub>|, |<italic>Y</italic><sub><italic>i </italic></sub>- <italic>Y</italic><sub><italic>j</italic></sub>|, and |<italic>Z</italic><sub><italic>i </italic></sub>- <italic>Z</italic><sub><italic>j</italic></sub>| between all pair of residues <italic>i </italic>and <italic>j </italic>to <italic>&#x003b7;</italic><italic>N </italic>where <italic>N </italic>is the length of the primary list. If <italic>&#x003b7; </italic>is low (e.g. 0.2), this constraint imposes a compact form to the protein and strongly reduces the running time.</p><p>One of the structural constraints considered is the presence of disulfide bonded residues (ssbonds). The rigid structure of the lattice is such that a low value of Euclidean distance (e.g., 2) between ssbonds often precludes all possible solutions. For this reason the default is chosen as 6. However, in some cases we tried computations with lower value. In these cases in the table the text <italic>ss </italic>= <italic>&#x003b3; </italic>is reported.</p><p>The secondary structure, as computed from the deposited structure in PDB, has been input as constraint. As a unique exception, in the case of 1VII(*) we have instead predicted it using the <italic>GOR IV </italic>secondary structure prediction method [<xref ref-type="bibr" rid="B19">19</xref>].</p><p>The predicted structures have been also transformed into all atoms models as described in the <bold>Detailed models from lattice models </bold>Section. There is some improvement in general on RMSD from native structure. This is especially significant when the starting structure is already close to the native one, being not merely due to increasing compactness of the structure. It is moreover reassuring that the procedure we are discussing is able to recover realistic models starting from the very simplified lattice models. The RMSDs of the resulting detailed models from the corresponding native structures are reported in Table <xref ref-type="table" rid="T2">2</xref>. In order to assess the quality of the detailed model, the trace of the native structure and the reconstructed and optimized all-atom model are shown in Figure <xref ref-type="fig" rid="F3">3</xref> for the core residues (7 to 30) of the WW domain (PDB id.: 1E0M).</p><p>We conclude the section comparing some results of our prediction with those returned by the well-known HMMSTR/Rosetta Prediction System [<xref ref-type="bibr" rid="B20">20</xref>]. This program does not use a lattice as underlying model: aminoacids are free to take any position in &#x0211d;<sup>3</sup>. For the sake of comparison, we have used it as an <italic>ab-initio </italic>predictor (precisely, we have disabled the <italic>homology </italic>and <italic>psi-blast </italic>options). The comparison is obviously not fair because in our case secondary structure is known and not predicted. Times are obtained from the result files, but it is not clear to which machine/CPU occupation they refer. Results are reported in Table <xref ref-type="table" rid="T3">3</xref>. HMMSTR/Rosetta prediction runs presumably faster, but our predictions (which however include known secondary structure) improve the RMSD (except for one case).</p></sec><sec><title>Constrained molecular dynamics simulation</title><p>We have used secondary structure information in conjunction with the well-established methodology of molecular dynamics simulations in order to implement a procedure similar to the one implemented using <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> on the <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> lattice. Secondary structure elements have been imposed through a constraining potential as described in the <bold>Methods </bold>Section. In order to search the conformational space a simulated annealing procedure has been adopted. Globularity of the simulated proteins is forced by a harmonic constraint on the radius of gyration.</p><p>The simulation time, ranging approximately between one and four CPU days, required for folding each protein on a 1.533 GHz AMD Athlon processor is reported in Table <xref ref-type="table" rid="T2">2</xref>. The columns (from left to right) in Table <xref ref-type="table" rid="T2">2</xref> report the PDB identification code of the protein, the number of residues, the RMSD from native structure computed on C<sub><italic>&#x003b1; </italic></sub>atoms on the whole protein and only on core residues and the simulation time. The last column reports the RMSD from native structure for models obtained by <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> after addition of all atoms and energy minimization as described in the <bold>Methods </bold>Section.</p><p>The simulation time needed for obtaining structures similar to native structures increases with the size of the protein both for the increasing size of the system and for the longer simulated annealing runs needed because of increasing complexity of the free energy landscape. Unfortunately a safer scheme would employ substantially longer simulation times.</p><p>This fact prompts for searching alternative ways to employ the same ideas.</p><p>The results in terms of RMSD from native structure support the idea that folding may be achieved, at least in simulation, by a hierarchical approach where local secondary structure elements are formed first and later their arrangement and contacts are optimized. A similar conclusion has been reached using a different model by Maritan and coworkers [<xref ref-type="bibr" rid="B21">21</xref>]. The RMSD on core residues is, in all but one case, less than 5.0 &#x000c5;. In four out of six cases the RMSD on core residues is close to 4.0 &#x000c5;. In the worst case, which is also the longest simulated chain, the RMSD on core residues is 7.1 &#x000c5;.</p></sec></sec><sec><title>Conclusions</title><p>The purpose of the present work was to demonstrate that the protein folding problem can be approached by a well-established programming paradigm like <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/>. With respect to the few applications reported in the literature so far using the same methodology [<xref ref-type="bibr" rid="B22">22</xref>], mainly on the HP protein model [<xref ref-type="bibr" rid="B23">23</xref>,<xref ref-type="bibr" rid="B24">24</xref>], the present work takes a step further towards more realistic modeling. Notwithstanding the use of a protein simplified lattice model with a simple contact potential realistic models for a few small proteins have been generated by using <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/>. In the present application the known secondary structure of the protein has been imposed as a constraint. <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> has been applied on face centered cubic lattice models of proteins where every aminoacid is represented by a single point on the lattice that can take one out of six possible positions with respect to the previous three aminoacids. It is immediately seen that the time needed for a systematic space search for such model grows exponentially with the number of free aminoacids. <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> is a programming paradigm that is suited for the solution of optimization combinatorial problems. In <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> the problem and the related heuristics are extremely natural to be programmed. Moreover, the constraint propagation allows to control the search in the huge solution's space.</p><p>The results obtained using this approach and reported in Tables <xref ref-type="table" rid="T1">1</xref> to <xref ref-type="table" rid="T3">3</xref> show that for small proteins a solution for the optimization problem is obtained in less than few hours. For the larger proteins studied here the inaccuracies of both the lattice model and contact potential prevent finding a compact solution. These problems are more likely to appear with increasing size of the protein and when the length of non-constrained chain connecting two secondary structure elements is short, because the lattice allows a limited set of conformations.</p><p>Further work is being devoted towards a more realistic modeling representation of the protein, with at least two centers of interaction per residue, and towards refinement of the potential function by including a term for rotamer preferences. This term should map on the lattice the directional preferences of each unit with respect to the previous three units. Each of the six possible next positions for each unit should be weighted by an energy term derived from database analysis.</p><p>Also the optimal size of non constrained parts of the chain will be determined in order to allow more possible relative orientations among constrained secondary structure elements, possibly without increasing significantly the computation time. At present, however, when the positions of all atoms are reconstructed from the lattice C<sub><italic>&#x003b1; </italic></sub>trace, the RMSD on core residues of the resulting models, after energy minimization, compared to native structures, is as low as 4.8 &#x000c5; for the thermostable domain of villin headpiece (PDB id.: 1VII), 3.6 &#x000c5; for the WW domain (PDB id.: 1E0M), 2.3 &#x000c5; for the coat protein-binding domain of bacteriophage P22 (PDB id.: 2GP8).</p><p>It should be also noted that both the thermostable domain of villin headpiece and the WW contain three secondary structure elements that can be arranged in different ways in order to produce a compact structure. The low RMSD is therefore significant.</p><p>A comparable protocol employing a molecular dynamics simulated annealing procedure still leads to superior results for larger proteins, as expected because the protein representation is more accurate, but it takes longer execution times between one and four days on a 1.5 GHz P3 machine.</p><p>Recent results have shown that simplified models and more refined models can be employed successfully in hierarchical modeling procedures [<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B10">10</xref>]. The results obtained in the present work suggest that <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> could be useful for finding starting conformations for further refinement.</p></sec><sec sec-type="methods"><title>Methods</title><sec><title>The protein structure prediction problem as a minimization problem</title><p>The sequence of aminoacids defining a protein is called <italic>primary structure</italic>. This structure uniquely determines the (3D) native conformation, also known as <italic>tertiary structure</italic>. The <italic>protein structure prediction problem </italic>is the problem of predicting the tertiary structure of a protein given its primary structure. The native tertiary structure minimizes the global free energy of the protein.</p></sec><sec><title>Abstraction level</title><p>We consider each aminoacid as a single <italic>sphere </italic>centered in its <italic>C</italic><sub><italic>&#x003b1; </italic></sub>atom; the distance between two consecutive <italic>C</italic><sub><italic>&#x003b1; </italic></sub>atoms is assumed to be 3.8 &#x000c5; Recent results (see, e.g., [<xref ref-type="bibr" rid="B13">13</xref>]) show that a contact between two residues, when represented only by their <italic>C</italic><sub><italic>&#x003b1; </italic></sub>atoms, is optimally defined for <italic>C</italic><sub><italic>&#x003b1; </italic></sub>- <italic>C</italic><sub><italic>&#x003b1; </italic></sub>distances shorter than 6.4 &#x000c5; The number is obtained as the sum of the radius of the two <italic>C</italic><sub><italic>&#x003b1; </italic></sub>carbon atoms we are dealing with (2 x 1.9 &#x000c5;) and the value of 2.6 &#x000c5; empirically determined in [<xref ref-type="bibr" rid="B13">13</xref>] for van der Waals surface contact. A table that points out the energy associated to pairs of aminoacids in <italic>contact </italic>has been developed [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>]. Let us denote by Pot(<italic>x</italic>, <italic>y</italic>) the energy value associated to a contact between aminoacids <italic>x </italic>and <italic>y </italic>(the order is immaterial); this value can either be positive or negative, according to the pair <italic>x</italic>, <italic>y</italic>.</p></sec><sec><title>Lattice model</title><p>According to [<xref ref-type="bibr" rid="B25">25</xref>] we use the <italic>Face-Centered Cubic Lattice </italic>(<inline-graphic xlink:href="1471-2105-5-186-i1.gif"/>) that allows realistic angles between consecutive residues. The lattice is composed by cubes of size 2, where the central point of each face and the vertices are admitted. Thus, the domain <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> consists in a set of triples &#x0003c;<italic>x</italic>, <italic>y</italic>, <italic>z</italic>&#x0003e; where &#x0003c;<italic>x</italic>, <italic>y</italic>, <italic>z </italic>&#x02208; &#x0003e;. We recall that given a point &#x0003c;<italic>x</italic>, <italic>y</italic>, <italic>z</italic>&#x0003e;, its <italic>2-norm </italic>is: ||&#x0003c;<italic>x</italic>, <italic>y</italic>, <italic>z</italic>&#x0003e;|| = <inline-graphic xlink:href="1471-2105-5-186-i4.gif"/>. Given two points <italic>p</italic><sub>1 </sub>and <italic>p</italic><sub>2</sub>, ||<italic>p</italic><sub>1 </sub>- <italic>p</italic><sub>2</sub>|| is known as their <italic>Euclidean distance</italic>.</p><p>Going back to the <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> lattice, two points at Euclidean distance <inline-graphic xlink:href="1471-2105-5-186-i5.gif"/> are linked together, forming a <italic>lattice unit</italic>, corresponding to the distance of 3.8 &#x000c5;. In this lattice, each point is adjacent to 12 neighboring points. A <italic>contact </italic>is defined between two non adjacent residues placed on two vertices of a side of a cube (i.e. they have Euclidean distance equal to 2, corresponding to 5.4 &#x000c5;). This number can be considered a good approximation of the limit of 6.4 &#x000c5; described above.</p></sec><sec><title>Mathematical formalization</title><p>In this setting, it is possible to formalize the protein folding problem as an optimization problem. Given a sequence <italic>S </italic>= <italic>s</italic><sub>1 </sub>... <italic>s</italic><sub><italic>n</italic></sub>, with <italic>s</italic><sub><italic>i </italic></sub>aminoacids, a <italic>fold </italic>of <italic>S </italic>is a function <italic>&#x003c9; </italic>: {1, ..., <italic>n</italic>} &#x02192; <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> such that: ||<italic>&#x003c9;</italic>(<italic>i</italic>) - <italic>&#x003c9;</italic>(<italic>i </italic>+ 1)|| = <inline-graphic xlink:href="1471-2105-5-186-i5.gif"/> and ||<italic>&#x003c9;</italic>(<italic>i</italic>) - <italic>&#x003c9;</italic>(<italic>j</italic>)|| &#x02265; 2 for <italic>i </italic>&#x02260; <italic>j</italic>. The first constraint states that consecutive aminoacids have a fixed distance, corresponding to one lattice unit; the second that each aminoacid occupies a unitary sphere and that two spheres cannot overlap.</p><p>The protein folding problem can be reduced to the optimization problem of finding the fold <italic>&#x003c9; </italic>of <italic>S </italic>such that the following energy is minimized [<xref ref-type="bibr" rid="B26">26</xref>,<xref ref-type="bibr" rid="B27">27</xref>]:</p><p><inline-graphic xlink:href="1471-2105-5-186-i6.gif"/></p><p>where contact(<italic>&#x003c9;</italic>(<italic>i</italic>), <italic>&#x003c9;</italic>(<italic>j</italic>)) is 1 if ||<italic>&#x003c9;</italic>(<italic>i</italic>) - <italic>&#x003c9;</italic>(<italic>j</italic>)|| = 2, 0 otherwise. To avoid solutions equivalent modulo simple symmetries, other constraints can be added on the first positions.</p></sec><sec><title>Complexity issues</title><p>The decision version of this problem (and even of its HP-abstraction) is proven to be NP-complete on various lattices [<xref ref-type="bibr" rid="B28">28</xref>,<xref ref-type="bibr" rid="B29">29</xref>]. However, we do not want to solve the problem for proteins of arbitrary length. Solving it for length <italic>N </italic>= 200&#x02013;300 could be considered as an important contribution to biological sciences and there are yet such results using the HP-abstraction [<xref ref-type="bibr" rid="B30">30</xref>]. Thus, in spite of its NP-completeness, it is important to understand the size of the solution's space. The size of the solution's space is the number of <italic>self-avoiding walks </italic>on the <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> lattice that can be approximated by the formula (cf., e.g., [<xref ref-type="bibr" rid="B31">31</xref>])</p><p><italic>SAW</italic><sub><italic>fcc </italic></sub>= 1.26<italic>N</italic><sup>0.162</sup>(10.0364)<sup><italic>N </italic></sup>&#x000a0;&#x000a0;&#x000a0; (2)</p><p>This formula should modify in the presence of additional constraints as mentioned later.</p></sec><sec><title>Main implementation issues</title><p>Our implementation of the protein folding minimization problem described in the above sections is based on the code briefly introduced in the <bold>Background </bold>Section. The complete program and related material can be found in [<xref ref-type="bibr" rid="B32">32</xref>]. The program consists of ~2000 lines and, once loaded in SICStus Prolog, one may call goals of the kind reported in Figure <xref ref-type="fig" rid="F4">4</xref>, where Protein_Name is a standard PDB identification code, such as 1ENH. Time is the maximum amount of time in seconds that we let to the runtime; the default is 10 hours. CompactFactor allows to impose an additional constraint on the maximal distance between every pair of aminoacids. The rationale behind this additional constraint stems from the observation that protein structures are more compact than expected based on a freely rotating chain model [<xref ref-type="bibr" rid="B33">33</xref>]. In particular, the average end-to-end distance for a freely rotating chain model is approximated by <inline-graphic xlink:href="1471-2105-5-186-i7.gif"/> where &#x02113; is the length of each unit and <italic>&#x003b1; </italic>is the cosine of the angle made by each unit with the direction of the preceding unit. The average end-to-end distance is clearly related to the average maximal dimension of the chain. Based on a survey of protein structures Huang and Powers derived the following approximated formula for the radius of gyration (in &#x000c5;): 2.2<italic>N</italic><sup>0.38 </sup>[<xref ref-type="bibr" rid="B34">34</xref>]. Note that the exponent is less than 0.5 which is an underestimate of the exponent for a self avoiding walk. For a uniform density sphere the diameter is <inline-graphic xlink:href="1471-2105-5-186-i8.gif"/> the radius of gyration. The default value for CompactFactor was therefore assumed to be approximately equal to <inline-graphic xlink:href="1471-2105-5-186-i8.gif"/> times the radius of gyration which in turn was computed by the empirical formula 2.2<italic>N</italic><sup>0.38 </sup>[<xref ref-type="bibr" rid="B34">34</xref>].</p><p>The auxiliary file data.pl stores the Primary and Secondary structures of the proteins that one wishes to test, as, for instance in the example reported in Figure <xref ref-type="fig" rid="F5">5</xref>. The output in standard PDB format [<xref ref-type="bibr" rid="B3">3</xref>] is printed either on the screen or in a file named output-Protein_name.pdb.</p></sec><sec><title>Constraints</title><p>The intrinsic complexity of the problem forces us to introduce several other constraints. For instance, we constrain the sum of the coordinates of each aminoacid in the <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> lattice to be even (a property of the <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> lattice) and we add some constraints for avoiding equivalent symmetric solutions. In what follows, we refer to predicate names as used in the code. avoid_symmetries removes redundant admissible conformations equivalent to others modulo some symmetries and/or rotations. The predicate assigns immediately three consecutive aminoacids positions (in the Tertiary list).</p><p>With distance_constraints, we also impose that two non consecutive residues must be separated by more than one lattice unit, to reflect the steric interaction between the <italic>C</italic><sub><italic>&#x003b1;</italic></sub>s modelling aminoacids.</p><p>As described above, compact_constraints imposes that, for every pair of aminoacids, the norm of the projection of their distance on each <italic>x</italic>, <italic>y</italic>, <italic>z </italic>coordinate, is smaller than CompactFactor &#x000d7; N.</p><p>Further constraints are related to angles. In the <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> lattice, the angle between three consecutive residues can assume values in {60&#x000b0;, 90&#x000b0;, 120&#x000b0;, 180&#x000b0;}. In real proteins, steric occupancy and energetic potential show a clear distribution of bend angles in the range 90&#x000b0;&#x02013;150&#x000b0; [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B35">35</xref>]. When transferring on <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> lattice, it is a good approximation to exclude 60&#x000b0; and 180&#x000b0; angles, as unfeasible. This constraint allows us to restrict the search space from a number close to 10<sup><italic>N </italic></sup>(cf. formula (2)) to a number close to 5<sup><italic>N</italic></sup>.</p><p>As said in the <bold>Lattice model </bold>Section, a <italic>contact </italic>is generated by two non consecutive aminoacids with Euclidean distance less than or equal to 2. As a consequence of the constraints applied, it suffices to check for a contact when the lattice distance equals 2, since distance_constraints excludes from the domain the possibility to place two non consecutive aminoacids at one lattice unit.</p><p>We also impose constraints coming from secondary structure information. Secondary structure can be predicted with good approximation (e.g., [<xref ref-type="bibr" rid="B36">36</xref>]). In our set of data we have collected such information from the Protein Data Bank. We represent secondary structure information as helix(<italic>i</italic>, <italic>j</italic>): elements <italic>i</italic>, <italic>i </italic>+ 1, ..., <italic>j </italic>of the input sequence form an <italic>&#x003b1;</italic>-helix; strand(<italic>i</italic>, <italic>j</italic>): elements <italic>i</italic>, <italic>i </italic>+ 1, ..., <italic>j </italic>are in a <italic>&#x003b2;</italic>-strand; ssbond(<italic>i</italic>, <italic>j</italic>): there is a disulfide bridge between element number <italic>i </italic>and <italic>j</italic>.</p><p>We use an auxiliary list called <italic>Indexes </italic>that stores torsional angles defined by four consecutive aminoacid positions. Due to <inline-graphic xlink:href="1471-2105-5-186-i1.gif"/> lattice structure and our constraints, every four consecutive aminoacids can form only 6 discrete angles. Thus, each variable in Indexes can assume a value <italic>i </italic>from {0, ..., 5}, representing torsional angles of 0&#x000b0;, 60&#x000b0;, 120&#x000b0;, 180&#x000b0;, 240&#x000b0;, 300&#x000b0;, respectively. With these conventions, helices are approximated by sequences of indexes of the form 5, 5, 5, ... while <italic>&#x003b2;</italic>-strands are associated to sequences of the form 3, 3, 3, .... Note that specifying the coordinates of three points (i.e. to place and orient the protein) and the indexes, uniquely determines the conformation, ssbond(<italic>i</italic>, <italic>j</italic>), introduces a maximum distance constraint between the aminoacids <italic>i </italic>and <italic>j</italic>. The predicate energy_constrain is developed using an auxiliary symmetric matrix <italic>M</italic>. The optimal fold is reached when the sum of <italic>M </italic>elements is minimal. During the <italic>labeling </italic>phase, the information stored in <italic>M </italic>is used to control the minimization process and to cut the search tree.</p></sec><sec><title>Labeling stage</title><p>To reduce the size of the solution's space visited during execution, we have replaced the built-in labeling predicate with an ad-hoc constraint-based solution search predicate, called <bold>solutions_search</bold>. We describe here briefly the main features of this predicate and of its auxiliary predicates.</p><p><bold>solutions_search</bold> &#x02022; If the <bold>Tertiary list</bold> or the <bold>Indexes</bold> list is ground (already computed), then it terminates the folding process (possibly, after a call to the built-in labeling).</p><p>&#x02022; Otherwise, it calls <bold>choose_labeling</bold>. When this procedure terminates, it calls recursively <bold>solutions_search</bold>. Termination is guaranteed by the fact that each call to <bold>choose_labeling</bold> reduces the number of non-ground variables.</p><p><bold>choose_labeling</bold> &#x02022; If the number of variables to be instantiated is low (in our code less than 4), it calls the built-in labeling.</p><p>&#x02022; Otherwise, it calls <bold>selection_strategy</bold>. This predicate computes several subsequences of the list of <bold>Indexes</bold>. Each subsequence consists of alternations of ground elements and non-ground variables. <bold>selection_strategy </bold>selects the <italic>most known subsequence</italic>, namely the one containing the smallest ratio of variable over ground indexes, preferring the ones that include a ssbond. If in the selected subsequence there are too many variables, an arbitrary subsequence cut is done. After the subsequence is selected, the procedure <bold>labeling_new_launch</bold> is called.</p><p><bold>labeling_new_launch</bold> It calls the auxiliary predicate<bold> labeling_new</bold> but stops the solution search when the global runtime is greater than the input time limit. If this is the case, the best computed solution is returned.</p><p><bold>labeling_new</bold> This procedure receives the chosen sublist to be folded. Each index variable in it, is assigned an admissible value between 0 and 5. The order of values that is tried for each index is described by a pre-computed auxiliary list. For each torsional index, a frequency statistics of the 6 indexes is pre-computed and extracted from the PDB, according to the specific aminoacid sequence involved locally. We use this information to direct the search and explore first the most common torsional angles, in the hope that this selection rule reflects nature's strategy.</p><p>Moreover, the energy associated to the fold is minimized. For doing that, after each instantiation of a fixed number <italic>t </italic>of variables in a phase, we collect the best known ground admissible solution, its energy and its associated potential matrix. We compare the current status to history and decide if it is reasonable to cut the search tree. In particular, we designed a heuristic that allows to control the effectiveness of the cut, adapting it dynamically to the status of the fold. Practically, when the protein is partially specified, we estimate the ratio between ground and non-ground variables in the potential matrix. If the ratio is low (i.e. the protein is poorly determined), we allow the current energy to be worse than the corresponding counterpart in the best fold so far reached. When the ratio is high (i.e. protein almost folded) we constrain the current energy to be slightly lower than the previous best known.</p></sec><sec><title>Molecular dynamics simulations</title><p>In order to have a fair comparison with a similar approach using all-atom protein models we built detailed all atom models for six proteins in the studied set (namely those with PDB id. code: 1VII, 1E0M, 2GP8, 1ENH, 2IGD, 1YPA) and imposed, through torsional constraints, the secondary structure geometry found in the native structure. The constraining potential was 100 * (<italic>&#x003b8; </italic>- <italic>&#x003b8;</italic><sub>0</sub>)<sup>2 </sup>kcal/(mol rad<sup>2</sup>). The reference target angles (i.e. <italic>&#x003b8;</italic><sub>0 </sub>in the previous formula) were set to <italic>&#x003c6; </italic>= -139 and <italic>&#x003c8; </italic>= 135 for residues in <italic>&#x003b2;</italic>-strand and to <italic>&#x003c6; </italic>= -48 and <italic>&#x003c8; </italic>= -57 for residues in <italic>&#x003b1;</italic>-helices. For all constrained residues also the <italic>&#x003c9; </italic>dihedral angle was constrained at 180 degrees.</p><p>The chain was first built fully extended and minimized by 400 steepest descent minimization steps and by 500 conjugate gradients minimization steps.</p><p>The protein was then heated in 10 ps up to 900 K in 20000 steps using a timestep of 0.0005 ps. Then the temperature was lowered down to 270 K in 20 steps. During each step molecular dynamics simulation was carried out for 100 ps for a total simulation time of 2 ns.</p><p>Simulations used the Generalized Born implicit solvent method [<xref ref-type="bibr" rid="B37">37</xref>] as implemented in the program CHARMM [<xref ref-type="bibr" rid="B38">38</xref>] with standard parameters for proteins. The forcefield used was CHARMM v.27 [<xref ref-type="bibr" rid="B39">39</xref>].</p><p>In order to obtain globular protein during simulation a constraint on the radius of gyration (computed only on C<sub><italic>&#x003b1; </italic></sub>atoms) was imposed. The target radius was decreased during the simulation from a value proper of an extended conformation down to the value given by 2.2<italic>N</italic><sup>0.38 </sup>[<xref ref-type="bibr" rid="B34">34</xref>] where <italic>N </italic>is the number of residues.</p><p>The potential used for enforcing compactness was: <inline-graphic xlink:href="1471-2105-5-186-i9.gif"/> kcal/mol, where <inline-graphic xlink:href="1471-2105-5-186-i10.gif"/>, <italic>n </italic>is the number of atoms, <italic>r</italic><sub><italic>cg </italic></sub>is the center of geometry of the same group of atoms, and <italic>R</italic><sub><italic>g</italic>0 </sub>is the target gyration radius which is decreased during simulated annealing down to the theoretical value based on the formula cited above.</p></sec><sec><title>Detailed models from lattice models</title><p>The models obtained by <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> described here may be converted into all-atom models which are realistic models of proteins. As a test the structures of all the proteins tested by simulated annealing described above were converted using the Maxsprout server [<xref ref-type="bibr" rid="B40">40</xref>] into an all heavy atom model. Hydrogens have been added using the module HBUILD in the program CHARMM [<xref ref-type="bibr" rid="B38">38</xref>] and the resulting structure was relaxed by energy minimization (using a distance dependent dielectric constant). First a minimization was performed with all backbone atoms fixed, then only C<sub><italic>&#x003b1; </italic></sub>atoms were fixed and finally a 100 ps molecular dynamics simulation (following a heating phase of 10 ps) using the Generalized Born implicit solvent model was performed. The resulting structure at the end of the simulation was energy minimized.</p><p>The initial minimizations required 1500 minimization steps each, because the starting structures were built from the lattice models. The final minimization, on the structure relaxed by molecular dynamics simulation, employed 900 minimization steps. During molecular dynamics simulation the radius of gyration and backbone torsion angles corresponding to residues constrained in the <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/>(<inline-graphic xlink:href="1471-2105-5-186-i3.gif"/>) procedure were constrained as described above.</p></sec></sec></body><back><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Moult</surname><given-names>J</given-names></name><name><surname>Hubbard</surname><given-names>T</given-names></name><name><surname>Fidelis</surname><given-names>K</given-names></name><name><surname>Pedersen</surname><given-names>J</given-names></name></person-group><article-title>Critical Assessment of Methods of Protein Structure Prediction (CASP): Round III</article-title><source>Proteins: Struct Funct Genet</source><year>1999</year><fpage>2</fpage><lpage>6</lpage><pub-id pub-id-type="pmid">10526346</pub-id></citation></ref><ref id="B2"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Venclovas</surname><given-names>C</given-names></name><name><surname>Zemla</surname><given-names>A</given-names></name><name><surname>Fidelis</surname><given-names>K</given-names></name><name><surname>Moult</surname><given-names>J</given-names></name></person-group><article-title>Assessment of progress over the CASP experiments</article-title><source>Proteins: Struct Funct Genet</source><year>2003</year><fpage>585</fpage><lpage>595</lpage><pub-id pub-id-type="pmid">14579350</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Berman</surname><given-names>HM</given-names></name><name><surname>Westbrook</surname><given-names>J</given-names></name><name><surname>Feng</surname><given-names>Z</given-names></name><name><surname>Gilliland</surname><given-names>G</given-names></name><name><surname>Bhat</surname><given-names>TN</given-names></name><name><surname>Weissig</surname><given-names>H</given-names></name><name><surname>Shindyalov</surname><given-names>IN</given-names></name><name><surname>Bourne</surname><given-names>PE</given-names></name></person-group><article-title>The Protein Data Bank</article-title><source>Nucleic Acids Res</source><year>2000</year><volume>28</volume><fpage>235</fpage><lpage>242</lpage><pub-id pub-id-type="pmid">10592235</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Skolnick</surname><given-names>J</given-names></name><name><surname>Kolinski</surname><given-names>A</given-names></name></person-group><article-title>Reduced models of proteins and their applications</article-title><source>Polymer</source><year>2004</year><volume>45</volume><fpage>511</fpage><lpage>524</lpage></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bashford</surname><given-names>D</given-names></name><name><surname>Chothia</surname><given-names>C</given-names></name><name><surname>Lesk</surname><given-names>A</given-names></name></person-group><article-title>Determinants of a protein fold. Unique features of the globin amino acid sequences</article-title><source>J Mol Biol</source><year>1987</year><volume>196</volume><fpage>199</fpage><lpage>216</lpage><pub-id pub-id-type="pmid">3656444</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Godzik</surname><given-names>A</given-names></name><name><surname>Kolinski</surname><given-names>A</given-names></name><name><surname>Skolnick</surname><given-names>J</given-names></name></person-group><article-title>Lattice representations of globular proteins: how good are they?</article-title><source>J Comp Chem</source><year>1993</year><volume>14</volume><fpage>1194</fpage><lpage>1202</lpage></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Toma</surname><given-names>T</given-names></name><name><surname>Toma</surname><given-names>S</given-names></name></person-group><article-title>Folding simulation of protein models on the structure-based cubo-octahedral lattice with the Contact Interactions algorithm</article-title><source>Protein Sci</source><year>1999</year><volume>8</volume><fpage>196</fpage><lpage>202</lpage><pub-id pub-id-type="pmid">10210197</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Skolnick</surname><given-names>J</given-names></name><name><surname>Kolinski</surname><given-names>A</given-names></name></person-group><article-title>Simulations of the folding of a globular protein</article-title><source>Science</source><year>1990</year><volume>250</volume><fpage>1121</fpage><lpage>1125</lpage></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Xia</surname><given-names>Y</given-names></name><name><surname>Huang</surname><given-names>ES</given-names></name><name><surname>Levitt</surname><given-names>M</given-names></name><name><surname>Samudrala</surname><given-names>R</given-names></name></person-group><article-title>Ab initio construction of protein tertiary structures using a hierarchical approach</article-title><source>J Mol Biol</source><year>2000</year><volume>300</volume><fpage>171</fpage><lpage>185</lpage><pub-id pub-id-type="pmid">10864507</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>Y</given-names></name><name><surname>Kolinski</surname><given-names>A</given-names></name><name><surname>Skolnick</surname><given-names>J</given-names></name></person-group><article-title>TOUCHSTONE II: a new approach to ab initio protein structure prediction</article-title><source>Biophys J</source><year>2003</year><volume>85</volume><fpage>1145</fpage><lpage>1164</lpage><pub-id pub-id-type="pmid">12885659</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>L Mirny</surname><given-names>ES</given-names></name></person-group><article-title>Protein folding theory: from lattice to all-atom models</article-title><source>Annu Rev Biophys Biomol Struct</source><year>2001</year><volume>30</volume><fpage>361</fpage><lpage>96</lpage><pub-id pub-id-type="pmid">11340064</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Miyazawa</surname><given-names>S</given-names></name><name><surname>Jernigan</surname><given-names>RL</given-names></name></person-group><article-title>Residue-residue potentials with a favorable contact pair term and an unfavorable high packing density term, for simulation and threading</article-title><source>J Mol Biol</source><year>1996</year><volume>256</volume><fpage>623</fpage><lpage>644</lpage><pub-id pub-id-type="pmid">8604144</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Berrera</surname><given-names>M</given-names></name><name><surname>Molinari</surname><given-names>H</given-names></name><name><surname>Fogolari</surname><given-names>F</given-names></name></person-group><article-title>Amino acid empirical contact energy definitions for fold recognition in the space of contact maps</article-title><source>BMC Bioinformatics</source><year>2003</year><volume>4</volume></citation></ref><ref id="B14"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rost</surname><given-names>B</given-names></name></person-group><article-title>Protein secondary structure prediction continues to rise</article-title><source>J Struct Biol</source><year>2001</year><volume>134</volume><fpage>204</fpage><lpage>218</lpage><pub-id pub-id-type="pmid">11551180</pub-id></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Jaffar</surname><given-names>J</given-names></name><name><surname>Maher</surname><given-names>MJ</given-names></name></person-group><article-title>Constraint Logic Programming: A Survey</article-title><source>Journal of Logic Programming</source><year>1994</year><volume>19&#x02013;20</volume><fpage>503</fpage><lpage>581</lpage></citation></ref><ref id="B16"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Marriott</surname><given-names>K</given-names></name><name><surname>Stuckey</surname><given-names>PJ</given-names></name></person-group><source>Programming with Constraints</source><year>1998</year><publisher-name>The MIT Press, Cambridge, Mass</publisher-name></citation></ref><ref id="B17"><citation citation-type="other"><person-group person-group-type="author"><collab>Swedish Institute for Computer Science</collab></person-group><article-title>SICStus Prolog Home Page</article-title><ext-link ext-link-type="uri" xlink:href="http://www.sics.se/sicstus/"/></citation></ref><ref id="B18"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Sterling</surname><given-names>L</given-names></name><name><surname>Shapiro</surname><given-names>E</given-names></name></person-group><source>The art of Prolog</source><year>1997</year><edition>2</edition><publisher-name>The MIT Press, Cambridge, Mass</publisher-name></citation></ref><ref id="B19"><citation citation-type="other"><person-group person-group-type="author"><collab>P&#x000f4;le Biolnformatique Lyonnais</collab></person-group><article-title>GOR IV secondary structure prediction method</article-title><ext-link ext-link-type="uri" xlink:href="http://npsa-pbil.ibcp.fr"/></citation></ref><ref id="B20"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Simons</surname><given-names>K</given-names></name><name><surname>Bonneau</surname><given-names>R</given-names></name><name><surname>Ruczinski</surname><given-names>I</given-names></name><name><surname>Baker</surname><given-names>D</given-names></name></person-group><article-title>Ab initio protein structure prediction of CASP III targets using ROSETTA</article-title><source>Proteins: Struct Fund Genet</source><year>1999</year><volume>3</volume><fpage>171</fpage><lpage>176</lpage></citation></ref><ref id="B21"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hoang</surname><given-names>TX</given-names></name><name><surname>Seno</surname><given-names>F</given-names></name><name><surname>Banavar</surname><given-names>JR</given-names></name><name><surname>Cieplak</surname><given-names>M</given-names></name><name><surname>Maritan</surname><given-names>A</given-names></name></person-group><article-title>Assembly of protein tertiary structures from secondary structures using optimized potentials</article-title><source>Proteins: Struct Funct Genet</source><year>2003</year><volume>52</volume><fpage>155</fpage><lpage>165</lpage><pub-id pub-id-type="pmid">12833540</pub-id></citation></ref><ref id="B22"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Backofen</surname><given-names>R</given-names></name></person-group><article-title>The protein structure prediction problem: A constraint optimization approach using a new lower bound</article-title><source>Constraints</source><year>2001</year><volume>6</volume><fpage>223</fpage><lpage>255</lpage></citation></ref><ref id="B23"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Dill</surname><given-names>KA</given-names></name></person-group><article-title>Dominant forces in protein folding</article-title><source>Biochemistry</source><year>1990</year><volume>29</volume><fpage>7133</fpage><lpage>7155</lpage><pub-id pub-id-type="pmid">2207096</pub-id></citation></ref><ref id="B24"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Yue</surname><given-names>K</given-names></name><name><surname>Dill</surname><given-names>KA</given-names></name></person-group><article-title>Sequence-structure relationships in proteins and copolymers</article-title><source>Physical Review E</source><year>1993</year><volume>48</volume><fpage>2267</fpage><lpage>2278</lpage></citation></ref><ref id="B25"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Raghunathan</surname><given-names>G</given-names></name><name><surname>Jernigan</surname><given-names>RL</given-names></name></person-group><article-title>Ideal architecture of residue packing and its observation in protein structures</article-title><source>Protein Sci</source><year>1997</year><volume>6</volume><fpage>2072</fpage><lpage>2083</lpage><pub-id pub-id-type="pmid">9336831</pub-id></citation></ref><ref id="B26"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Clote</surname><given-names>P</given-names></name><name><surname>Backofen</surname><given-names>R</given-names></name></person-group><source>Computational Molecular Biology: An Introduction</source><year>2001</year><publisher-name>John Wiley &#x00026; Sons</publisher-name></citation></ref><ref id="B27"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Dal Pal&#x000f9;</surname><given-names>A</given-names></name><name><surname>Dovier</surname><given-names>A</given-names></name><name><surname>Fogolari</surname><given-names>F</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Apt KR, Fages F, Rossi F, Szeredi P, Vancza J</surname></name></person-group><article-title>Protein Folding in <italic>CLP</italic>(<inline-graphic xlink:href="1471-2105-5-186-i3.gif"/>) with Empirical Contact Energies</article-title><source>In Recent Advances in Constraints, of Lecture Notes in Artificial Intelligence</source><year>2004</year><volume>3010</volume></citation></ref><ref id="B28"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Crescenzi</surname><given-names>P</given-names></name><name><surname>Goldman</surname><given-names>D</given-names></name><name><surname>Papadimitrou</surname><given-names>C</given-names></name><name><surname>Piccolboni</surname><given-names>A</given-names></name><name><surname>Yannakakis</surname><given-names>M</given-names></name></person-group><article-title>On the complexity of protein folding</article-title><source>In Proc of STOC</source><year>1998</year><fpage>597</fpage><lpage>603</lpage></citation></ref><ref id="B29"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Hart</surname><given-names>WE</given-names></name><name><surname>Newman</surname><given-names>A</given-names></name></person-group><article-title>The Computational Complexity of Protein Structure Prediction in Simple Lattice Models</article-title><source>In Handbook on Algorithms in Bioinformatics</source><publisher-name>CRC Press</publisher-name><comment></comment></citation></ref><ref id="B30"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Backofen</surname><given-names>R</given-names></name><name><surname>Will</surname><given-names>S</given-names></name></person-group><article-title>A Constraint-Based Approach to Structure Prediction for Simplified Protein Models that Outperforms Other Existing Methods</article-title><source>In Proceedings of the 19th International Conference on Logic Programming (ICLP 2003), of Lecture Notes in Computer Science, Springer</source><year>2003</year><volume>2916</volume><fpage>49</fpage><lpage>71</lpage></citation></ref><ref id="B31"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Schuster</surname><given-names>P</given-names></name><name><surname>Stadler</surname><given-names>PF</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Crabbe MJC, Drew M, Konopka A</surname></name></person-group><article-title>Discrete Models of Biopolymers</article-title><source>In Handbook of Computional Chemistry</source><year>2001</year><publisher-name>Marcel Dekker, New York</publisher-name></citation></ref><ref id="B32"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Dovier</surname><given-names>A</given-names></name></person-group><article-title>Protein Folding with Constraints-Based Methods</article-title><ext-link ext-link-type="uri" xlink:href="http://www.dimi.uniud.it/dovier/PF"/></citation></ref><ref id="B33"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Cantor</surname><given-names>CR</given-names></name><name><surname>Schimmel</surname><given-names>PR</given-names></name></person-group><source>Biophysical chemistry</source><year>1980</year><publisher-name>W H Freeman and Co</publisher-name></citation></ref><ref id="B34"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Huang</surname><given-names>X</given-names></name><name><surname>Powers</surname><given-names>R</given-names></name></person-group><article-title>Validity of using the radius of gyration as a restraint in NMR protein structure detremination</article-title><source>J Am Chem Soc</source><year>2001</year><volume>123</volume><fpage>3834</fpage><lpage>3835</lpage><pub-id pub-id-type="pmid">11457122</pub-id></citation></ref><ref id="B35"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Fogolari</surname><given-names>F</given-names></name><name><surname>Esposito</surname><given-names>G</given-names></name><name><surname>Viglino</surname><given-names>P</given-names></name><name><surname>Cattarinussi</surname><given-names>S</given-names></name></person-group><article-title>Modeling of polypeptide chains as C-<italic>&#x003b1; </italic>chains, C-<italic>&#x003b1; </italic>chains with C-<italic>&#x003b2;</italic>, and C-<italic>&#x003b1; </italic>chains with ellipsoidal lateral chains</article-title><source>Biophys J</source><year>1996</year><volume>70</volume><fpage>1183</fpage><lpage>1197</lpage><pub-id pub-id-type="pmid">8785277</pub-id></citation></ref><ref id="B36"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Rost</surname><given-names>B</given-names></name><name><surname>Sander</surname><given-names>C</given-names></name></person-group><article-title>Prediction of Protein Secondary Structure at better than 70% accuracy</article-title><source>J Mol Biol</source><year>1993</year><volume>232</volume><fpage>584</fpage><lpage>599</lpage><pub-id pub-id-type="pmid">8345525</pub-id></citation></ref><ref id="B37"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Qiu</surname><given-names>D</given-names></name><name><surname>Shenkin</surname><given-names>P</given-names></name><name><surname>Hollinger</surname><given-names>F</given-names></name><name><surname>Still</surname><given-names>W</given-names></name></person-group><article-title>The GB/SA Continuum Model for Solvation. A Fast Analytical Method for the Calculation of Approximate Born Radii</article-title><source>J Phys Chem</source><year>1997</year><volume>101</volume><fpage>3005</fpage><lpage>3014</lpage></citation></ref><ref id="B38"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Brooks</surname><given-names>BR</given-names></name><name><surname>Bruccoleri</surname><given-names>RE</given-names></name><name><surname>Olafson</surname><given-names>BD</given-names></name><name><surname>States</surname><given-names>DJ</given-names></name><name><surname>Swaminathan</surname><given-names>S</given-names></name><name><surname>Karplus</surname><given-names>M</given-names></name></person-group><article-title>CHARMM: A Program for Macromolecular Energy Minimization and Dynamics Calculations</article-title><source>J Comp Chem</source><year>1983</year><volume>4</volume><fpage>187</fpage><lpage>217</lpage></citation></ref><ref id="B39"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>MacKerell</surname><given-names>ADJ</given-names></name><name><surname>Bashford</surname><given-names>D</given-names></name><name><surname>Bellott</surname><given-names>M</given-names></name><name><surname>Dunbrack</surname><given-names>RLJ</given-names></name><name><surname>Evanseck</surname><given-names>JD</given-names></name><name><surname>Field</surname><given-names>MJ</given-names></name><name><surname>Fischer</surname><given-names>S</given-names></name><name><surname>Gao</surname><given-names>J</given-names></name><name><surname>Guo</surname><given-names>H</given-names></name><name><surname>Ha</surname><given-names>S</given-names></name><name><surname>Joseph-McCarthy</surname><given-names>D</given-names></name><name><surname>Kuchnir</surname><given-names>L</given-names></name><name><surname>Kuczera</surname><given-names>K</given-names></name><name><surname>Lau</surname><given-names>FTK</given-names></name><name><surname>Mattos</surname><given-names>C</given-names></name><name><surname>Michnick</surname><given-names>S</given-names></name><name><surname>Ngo</surname><given-names>T</given-names></name><name><surname>Nguyen</surname><given-names>DT</given-names></name><name><surname>Prodhom</surname><given-names>B</given-names></name><name><surname>Reiher</surname><given-names>WEI</given-names></name><name><surname>Roux</surname><given-names>B</given-names></name><name><surname>Schlenkrich</surname><given-names>M</given-names></name><name><surname>Smith</surname><given-names>JC</given-names></name><name><surname>Stote</surname><given-names>R</given-names></name><name><surname>Straub</surname><given-names>J</given-names></name><name><surname>Watanabe</surname><given-names>M</given-names></name><name><surname>Wiorkiewicz-Kuczera</surname><given-names>J</given-names></name><name><surname>Yin</surname><given-names>D</given-names></name><name><surname>Karplus</surname><given-names>M</given-names></name></person-group><article-title>All-atom empirical potential for molecular modeling and dynamics Studies of proteins</article-title><source>J Phys Chem B</source><year>1998</year><volume>102</volume><fpage>3586</fpage><lpage>3616</lpage></citation></ref><ref id="B40"><citation citation-type="other"><person-group person-group-type="author"><collab>European Bioinformatics Institute</collab></person-group><article-title>MaxSprout: Reconstruction of 3D coordinates from C (alpha) trace</article-title><ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/maxsprout"/></citation></ref></ref-list><sec sec-type="display-objects"><title>Figures and Tables</title><fig position="float" id="F1"><label>Figure 1</label><caption><p>Main program predicate.</p></caption><graphic xlink:href="1471-2105-5-186-1"/></fig><fig position="float" id="F2"><label>Figure 2</label><caption><p>Code for stating that consecutive aminoacids must be in adjacent lattice points.</p></caption><graphic xlink:href="1471-2105-5-186-2"/></fig><fig position="float" id="F3"><label>Figure 3</label><caption><p>Native (yellow) and <inline-graphic xlink:href="1471-2105-5-186-i2.gif"/> model after all-atom reconstruction and optimization (red) for WW domain (PDB id. 1E0M). The trace of core residues (7&#x02013;30) is shown.</p></caption><graphic xlink:href="1471-2105-5-186-3"/></fig><fig position="float" id="F4"><label>Figure 4</label><caption><p>Program execution modes.</p></caption><graphic xlink:href="1471-2105-5-186-4"/></fig><fig position="float" id="F5"><label>Figure 5</label><caption><p>Protein sequence and secondary structure representation</p></caption><graphic xlink:href="1471-2105-5-186-5"/></fig><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Experimental results</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">Name</td><td align="center">N</td><td align="left">Time</td><td align="center">Energy</td><td align="center">RMSD</td></tr></thead><tbody><tr><td align="center">1LE0</td><td align="center">12</td><td align="left">1.3 s</td><td align="center">-9040</td><td align="center">2.8 / 2.6 (2&#x02013;11)</td></tr><tr><td align="center">1KVG</td><td align="center">12</td><td align="left">7.3 s</td><td align="center">-14409</td><td align="center">2.7 / 2.4 (3&#x02013;11)</td></tr><tr><td align="center">1LE3</td><td align="center">16</td><td align="left">2.3 s</td><td align="center">-13653</td><td align="center">3.0 / 2.7 (2&#x02013;1
5)</td></tr><tr><td align="center">1EDP</td><td align="center">17</td><td align="left">20.4 s</td><td align="center">-19389</td><td align="center">4.3 / 1.1 (9&#x02013;15)</td></tr><tr><td align="center">1PG1</td><td align="center">18</td><td align="left">14.6 s</td><td align="center">-10126</td><td align="center">6.0 / 5.2 (4&#x02013;17)</td></tr><tr><td align="center">1ZDD</td><td align="center">34</td><td align="left">300 s (limit)</td><td align="center">-20412</td><td align="center">5.6 / 5.6 (5&#x02013;34)</td></tr><tr><td></td><td></td><td align="left">17 m25 s</td><td align="center">-22350</td><td align="center">4.0 / 4.0 (5&#x02013;34)</td></tr><tr><td align="center">1VII</td><td align="center">36</td><td align="left">300 s (limit)</td><td align="center">-20860</td><td align="center">10.4 / 6.7 (4&#x02013;32)</td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-22377</td><td align="center">9.1 /6.3 (4&#x02013;32)</td></tr><tr><td></td><td></td><td align="left">7 h42 m</td><td align="center">-26408</td><td align="center">10.2 / 7.8 (4&#x02013;32)</td></tr><tr><td></td><td align="center">CF = 0.3</td><td align="left">3 h58 m</td><td align="center">-28710</td><td align="center">8.0 / 7.4 (4&#x02013;32)</td></tr><tr><td align="center">1VII(*)</td><td align="center">36</td><td align="left">300 s (limit)</td><td align="center">-17948</td><td align="center">9.2 / 7.3 (4&#x02013;32)</td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-17948</td><td align="center">9.2 /7.3 (4&#x02013;32)</td></tr><tr><td></td><td></td><td align="left">3 h20 m</td><td align="center">-21211</td><td align="center">10.3 / 6.9 (4&#x02013;32)</td></tr><tr><td align="center">1E0M</td><td align="center">37</td><td align="left">300 s (limit)</td><td align="center">-13830</td><td align="center">6.5 / 5.8 (8&#x02013;29)</td></tr><tr><td></td><td></td><td align="left">1200 s (limit)</td><td align="center">-24613</td><td align="center">8.4 / 3.6 (8&#x02013;29)</td></tr><tr><td></td><td></td><td align="left">10 h (limit)</td><td align="center">-26592</td><td align="center">8.8 / 3.4(8&#x02013;29)</td></tr><tr><td></td><td></td><td align="left">24 h (limit)</td><td align="center">-30163</td><td align="center">8.9 / 4.4 (8&#x02013;29)</td></tr><tr><td align="center">2GP8</td><td align="center">40</td><td align="left">300 s (limit)</td><td align="center">-10303</td><td align="center">10.5 / 8.9 (6&#x02013;38)</td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-24748</td><td align="center">4.1 / 3.5 (6&#x02013;38)</td></tr><tr><td></td><td></td><td align="left">10 h (limit)</td><td align="center">-26196</td><td align="center">4.9 / 3.5 (6&#x02013;38)</td></tr><tr><td></td><td></td><td align="left">10 h39 m</td><td align="center">-26196</td><td align="center">4.9 / 3.5 (6&#x02013;38)</td></tr><tr><td align="center">1ED0</td><td align="center">46</td><td align="left">300 s (limit)</td><td align="center">-29970</td><td align="center">7.3 / 4.1 (3&#x02013;40)</td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-32369</td><td align="center">8.6 / 7.1 (3&#x02013;40)</td></tr><tr><td></td><td></td><td align="left">9 h38 m</td><td align="center">-38218</td><td align="center">8.0 / 7.2 (3&#x02013;40)</td></tr><tr><td align="center">1ENH</td><td align="center">54</td><td align="left">300 s (limit)</td><td align="center">-12480</td><td align="center">10.4 / 8.9 (8&#x02013;52)</td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-12480</td><td align="center">10.4 / 8.9 (8&#x02013;52)</td></tr><tr><td></td><td></td><td align="left">10 h(limit)</td><td align="center">-23373</td><td align="center">9.9 / 8.6 (8&#x02013;52)</td></tr><tr><td></td><td></td><td align="left">24 h (limit)</td><td align="center">-23373</td><td align="center">9.9 / 8.6 (8&#x02013;52)</td></tr><tr><td align="center">6PTI</td><td align="center">58</td><td align="left">300 s (limit)</td><td align="center">no sol.</td><td></td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-29709</td><td align="center">10.0 / 9.7 (3&#x02013;55)</td></tr><tr><td></td><td></td><td align="left">10 h (limit)</td><td align="center">-37837</td><td align="center">10.0 / 9.7 (3&#x02013;55)</td></tr><tr><td></td><td></td><td align="left">24 h (limit)</td><td align="center">-37837</td><td align="center">10.0 / 9.7 (3&#x02013;55)</td></tr><tr><td></td><td align="center">CF = 0.25</td><td align="left">48 h (limit)</td><td align="center">-42096</td><td align="center">9.7 / 9.4 (3&#x02013;55)</td></tr><tr><td></td><td align="center">CF= 0.18</td><td align="left">24 h (limit)</td><td align="center">-47451</td><td align="center">10.9 / 10.7 (3&#x02013;55)</td></tr><tr><td align="center">2IGD</td><td align="center">60</td><td align="left">300 s (limit)</td><td align="center">-24158</td><td align="center">19.3 / 16.3 (6&#x02013;59)</td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-29178</td><td align="center">19.0 /16.2 (6&#x02013;59)</td></tr><tr><td></td><td></td><td align="left">10 h (limit)</td><td align="center">-37479</td><td align="center">16.9 / 15.0(6&#x02013;59)</td></tr><tr><td></td><td></td><td align="left">24 h (limit)</td><td align="center">-37479</td><td align="center">16.9 / 15.0 (6&#x02013;59)</td></tr><tr><td></td><td align="center">CF = 0.17</td><td align="left">4 h 59 m</td><td align="center">-40588</td><td align="center">12.6 / 11.5 (6&#x02013;59)</td></tr><tr><td align="center">2ERA</td><td align="center">61</td><td align="left">300 s (limit)</td><td align="center">-28993</td><td align="center">11.6 / 10.6 (3&#x02013;55)</td></tr><tr><td></td><td></td><td align="left">9 m28 s,</td><td align="center">-30746</td><td align="center">12. 3/ 12.1 (3&#x02013;55)</td></tr><tr><td></td><td align="center">ss = 5</td><td align="left">15 m13 s</td><td align="center">-31692</td><td align="center">12.7/11.6 (3&#x02013;55)</td></tr><tr><td></td><td align="center">CF = 0.25, ss = 5</td><td align="left">15 m12 s</td><td align="center">-33693</td><td align="center">10.9/9.3 (3&#x02013;55)</td></tr><tr><td></td><td align="center">CF = 0.25, ss = 4</td><td align="left">1000 s (limit)</td><td align="center">-32985</td><td align="center">12.3/12.4 (3&#x02013;55)</td></tr><tr><td></td><td align="center">CF = 0.19, ss = 5</td><td align="left">1000 s (limit)</td><td align="center">-34275</td><td align="center">10.6/8.9 (3&#x02013;55)</td></tr><tr><td></td><td align="center">CF = 0.19, ss = 4</td><td align="left">1000 s (limit)</td><td align="center">-38138</td><td align="center">11.6/10.6 (3&#x02013;55)</td></tr><tr><td align="center">1SN1</td><td align="center">63</td><td align="left">300 s (limit)</td><td align="center">no sol.</td><td></td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-53888</td><td align="center">13.0 / 10.5 (2&#x02013;51)</td></tr><tr><td></td><td></td><td align="left">10 h (limit)</td><td align="center">-57615</td><td align="center">11.9/ 9.6 (2&#x02013;51)</td></tr><tr><td></td><td align="center">CF = 0.25, ss = 5</td><td align="left">10 h (limit)</td><td align="center">-47121</td><td align="center">8.6 / 8.1 (2&#x02013;51)</td></tr><tr><td align="center">1YPA</td><td align="center">63</td><td align="left">300 s (limit)</td><td align="center">-36626</td><td align="center">16.1 / 9.4 (12&#x02013;52)</td></tr><tr><td></td><td></td><td align="left">1000 s (limit)</td><td align="center">-33886</td><td align="center">17.1 / 10.9 (12&#x02013;52)</td></tr><tr><td></td><td></td><td align="left">10 h (limit)</td><td align="center">-33886</td><td align="center">17.1 / 10.9 (12&#x02013;52)</td></tr><tr><td></td><td align="center">CF = 0.17</td><td align="left">100 s (limit)</td><td align="center">-26297</td><td align="center">12.5 / 10.5 (12&#x02013;52)</td></tr><tr><td></td><td align="center">CF = 0.17</td><td align="left">10 h (limit)</td><td align="center">-60244</td><td align="center">12.9 / 9.8 (12&#x02013;52)</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T2"><label>Table 2</label><caption><p>Summary of molecular dynamics results</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">Name</td><td align="center">N</td><td align="center">RMSD (&#x000c5;)</td><td align="center">Time</td><td align="center">RMSD (<graphic xlink:href="1471-2105-5-186-i2.gif"/> + opt) (&#x000c5;)</td></tr></thead><tbody><tr><td align="center">1VII</td><td align="center">36</td><td align="center">5.3 / 4.7 (4&#x02013;32)</td><td align="center">17.8 h (2 ns)</td><td align="center">5.8 / 4.8 (4&#x02013;32)</td></tr><tr><td align="center">1E0M</td><td align="center">37</td><td align="center">5.5 / 4.0 (7&#x02013;30)</td><td align="center">26.3 h (4 ns)</td><td align="center">8.7 / 3.6 (7&#x02013;30)</td></tr><tr><td align="center">2GP8</td><td align="center">40</td><td align="center">5.9 / 3.8 (6&#x02013;38)</td><td align="center">37.7 h (4 ns)</td><td align="center">3.9 / 2.3 (6&#x02013;38)</td></tr><tr><td align="center">1ENH</td><td align="center">54</td><td align="center">5.9 / 5.0 (8&#x02013;52) / 3.7 (8&#x02013;36)</td><td align="center">29.4 h (2 ns)</td><td align="center">11.2 / 10.7 (8&#x02013;52) / 4.7 (8&#x02013;36)</td></tr><tr><td align="center">2IGD</td><td align="center">61</td><td align="center">5.7 / 4.1 (6&#x02013;59)</td><td align="center">48.6 h (4 ns)</td><td align="center">12.9 / 11.5 (6&#x02013;59)</td></tr><tr><td align="center">1YPA</td><td align="center">64</td><td align="center">9.2 / 7.1 (12&#x02013;52)</td><td align="center">116.9 h (8 ns)</td><td align="center">11.8 / 9.4 (12&#x02013;52)</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T3"><label>Table 3</label><caption><p>Comparison with Rosetta predictions</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="center">Name</td><td align="center">N</td><td align="center"><graphic xlink:href="1471-2105-5-186-i2.gif"/> Time</td><td align="center"><graphic xlink:href="1471-2105-5-186-i2.gif"/> RMSD</td><td align="center">Rosetta Time</td><td align="center">Rosetta RMSD</td></tr></thead><tbody><tr><td align="center">1ZDD</td><td align="center">34</td><td align="center">17 m.25 s.</td><td align="center">4.0</td><td align="center">5 m.35 s.</td><td align="center">3.5</td></tr><tr><td align="center">1VII</td><td align="center">36</td><td align="center">3 h.58 m.</td><td align="center">7.4 (4&#x02013;32)</td><td align="center">5 m.35 s.</td><td align="center">4.2</td></tr><tr><td align="center">1E0M</td><td align="center">37</td><td align="center">10 h.</td><td align="center">3.4 (8&#x02013;29)</td><td align="center">6 m.35 s.</td><td align="center">7.7</td></tr><tr><td align="center">2GP8</td><td align="center">40</td><td align="center">10 h.</td><td align="center">3.5 (6&#x02013;38)</td><td align="center">6 m.35 s.</td><td align="center">6.4</td></tr><tr><td align="center">1ED0</td><td align="center">46</td><td align="center">10 h.</td><td align="center">7.2 (3&#x02013;40)</td><td align="center">7 m.23 s.</td><td align="center">8.9</td></tr></tbody></table></table-wrap></sec></back></article>



